import scipy as sp
import numpy as np
from skimage import measure
from mpl_toolkits.mplot3d import Axes3D



# %%  Functions
def _erode_im(im_distance, threshold, upper, lower):
    r"""
    Erosion of the Image with diameter threshold
    Returns an array with eroded pore space
    If threshold < 0 function returns zeros-array
    """
    if threshold < 0:
        im_eroded = np.ones(im_distance.shape) * lower
    else:
        im_eroded = np.where(im_distance > threshold, upper, lower)
    return im_eroded


def _dilate_im(im_distance, im_background, threshold, lower, upper):
    r"""
    Delation of the Image with diameter threshold
    Returns an array with delated pore space on original image im_background
    with regarding the non overlapping character of solid phase
    If delation threshold is <0 function returns zeros-array
    """
    if threshold < 0:
        im_opened_static = np.zeros(im_distance.shape)
    else:
        im_opened_dummy = (
            np.where(im_distance > threshold, lower, upper) - im_background
        )
        threshold, lower, upper = upper, 1, 0
        im_opened_static = np.where(im_opened_dummy == threshold, lower, upper)
        pass
    return im_opened_static


def dilate_im_gravity(im_distance2,
                      im_array,
                      step,
                      Deros0,
                      gamma,
                      rhoWP,
                      rhoNWP,
                      h_max,
                      g,
                      p0,
                      D2image,
                      dr):
    r"""
    #elation of the Image with various diameter Rdila which depends on height h
    Returns an array with delated pore space on original image im_background
    with regarding the non overlapping character of solid phase

    Approach:
    To consider several independent intruding NWP Phases with different
    heights and therefore different dilation diameters,
    image is dilated within several grid segments which regards Rdila(hmax(y),y)

    Different NWP Phases are located by variable 'stepsize'
    #rid is generated by counting different intruding NWP and split image
    in the mid distance between them
    Dilation is executed for each grid segment with it's consideration
    to a different Dilation distance
    """

    im_opened_static = np.zeros(im_distance2.shape)
    Lx = im_distance2.shape[0]
    Rdila = np.zeros([int(Lx / step) + 1])
    maximum_height = Lx

    for i in range(Lx):
        if D2image is True:
            if np.min(im_distance2[i, :]) > 0:
                maximum_height = i
                break
        else:
            if np.min(im_distance2[i, :, :]) > 0:
                maximum_height = i
                break

    for i in range(0, Lx, step):
        lower = i
        higher = i + step

        # Calculate Rdila with the mean height of the scope between lower
        # and higher value
        h = (lower + step / 2) * dr

        Rdila[int(i / step)] = (
            2 * gamma / (p0 - (rhoWP * g * (h_max - h) + rhoNWP * g * h)) / dr
        )
        if higher >= maximum_height:
            if i > 0:
                Rdila[int(i / step)] = Rdila[int((i - step) / step)]
                if higher > (maximum_height + Rdila[int(i / step)] + step):
                    break
            else:
                Rdila[int(i / step)] = 2 * gamma / (p0 - rhoWP * g * h_max) / dr
        if D2image is True:
            temp = dilate_im(
                im_distance2[lower:higher, :],
                im_array[lower:higher, :],
                Rdila[int(i / step)],
                0,
                upp,
            )
            im_opened_static[lower:higher, :] = temp
        else:
            temp = dilate_im(im_distance2[lower:higher, :, :],
                             im_array[lower:higher, :, :],
                             Rdila[int(i / step)], 0, upp)
            im_opened_static[lower:higher, :, :] = temp
    return im_opened_static


def Connectivity_Check(im_set, NwpR, D2img):
    r"""
    #Connectivity Check of array im_set
    #NwpR is input parameter for the intrusion side
    #D2img gives information about 3D or 2D image
    """
    im_set = measure.label(im_set, background=0)
    shape = im_set.shape

    if D2img is True:
        if NwpR == "-x":  # down
            dummy = im_set[0, :]
        elif NwpR == "x":  # top
            dummy = im_set[Lx - 1, :]
        elif NwpR == "-y":  # left
            dummy = im_set[:, 0]
        elif NwpR == "y":  # right
            dummy = im_set[:, Ly - 1]
            pass
    else:
        if NwpR == "-x":  # down
            dummy = im_set[0, :, :]
        elif NwpR == "x":  # top
            dummy = im_set[Lx - 1, :, :]
        elif NwpR == "-y":  # left
            dummy = im_set[:, 0, :]
        elif NwpR == "y":  # right
            dummy = im_set[:, Ly - 1, :]
        elif NwpR == "-z":  # back
            dummy = im_set[:, :, 0]
        elif NwpR == "-z":  # front
            dummy = im_set[:, :, Lz - 1]
            pass

    # make a unique set to get side values
    dummy = np.unique(dummy)
    dummy = np.delete(dummy, np.where(dummy == 0))

    # if we do not find an entry we skip the rest
    if dummy.size > 0:

        # Make a new blank image
        im_connected = sp.zeros(shape)

        # take only the components which are connected to one side
        for i in dummy:
            threshold, upper, lower = i, 1, 0
            im_connected = im_connected + np.where(im_set == threshold, upper, lower)
            pass

        im_connected_bool = sp.zeros(shape, dtype=bool)
        threshold, upper, lower = 1, False, True
        im_connected_bool = np.where(im_connected == threshold, upper, lower)
        return im_connected_bool
    else:
        return False
    pass


def eliminate_overlapping(im_opened_static, NwpR, D2img):
    r"""
    # Function to eliminate overlapping phase caused by contact angle or
    # gravity calculation (Rdila>Reros)
    # Approach: Find NWP-phases which is not connected to NWP-main phase
    """
    im_connected_matrix = (Connectivity_Check(im_opened_static, NwpR, D2img) - 1) * (-1)

    return im_connected_matrix

