<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <meta name="generator" content="sphinx-3.5.3, furo 2021.03.20.beta30"/>
        <title>porespy.filters.__funcs__ - PoreSpy documentation</title>
      <link rel="stylesheet" href="../../../_static/styles/furo.css?digest=978e1795dfe158b585dda6a8417f6411828bf3ed">
    <link rel="stylesheet" href="../../../_static/pygments.css">
    <link media="(prefers-color-scheme: dark)" rel="stylesheet" href="../../../_static/pygments_dark.css">
    


<style>
  :root {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  @media (prefers-color-scheme: dark) {
    :root {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
  }

  /* For allowing end-user-specific overrides */
  .override-light {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  .override-dark {
    --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
  }
</style><link rel="stylesheet" href="../../../_static/styles/furo-extensions.css?digest=d391b54134226e4196576da3bdb6dddb7e05ba2b"></head>
  <body dir="">
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke-width="1.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z"/>
      <line x1="4" y1="6" x2="20" y2="6" />
      <line x1="10" y1="12" x2="20" y2="12" />
      <line x1="6" y1="18" x2="20" y2="18" />
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
      class="feather feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
      class="feather feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">PoreSpy  documentation</div></a>
    </div>
    <div class="header-right">
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand centered" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../../../_static/porespy_logo.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">PoreSpy  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html">
  <input class="sidebar-search" placeholder=Search name="q">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../modules/index.html">Module and Function Reference</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label for="toctree-checkbox-1"><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../modules/generators.html">Generators</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label for="toctree-checkbox-2"><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.generators.blobs.html">porespy.generators.blobs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.generators.bundle_of_tubes.html">porespy.generators.bundle_of_tubes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.generators.cylindrical_plug.html">porespy.generators.cylindrical_plug</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.generators.cylinders.html">porespy.generators.cylinders</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.generators.fractal_noise.html">porespy.generators.fractal_noise</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.generators.insert_shape.html">porespy.generators.insert_shape</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.generators.lattice_spheres.html">porespy.generators.lattice_spheres</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.generators.line_segment.html">porespy.generators.line_segment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.generators.overlapping_spheres.html">porespy.generators.overlapping_spheres</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.generators.polydisperse_spheres.html">porespy.generators.polydisperse_spheres</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.generators.pseudo_electrostatic_packing.html">porespy.generators.pseudo_electrostatic_packing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.generators.pseudo_gravity_packing.html">porespy.generators.pseudo_gravity_packing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.generators.RSA.html">porespy.generators.RSA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.generators.voronoi_edges.html">porespy.generators.voronoi_edges</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../modules/filters.html">Filters</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label for="toctree-checkbox-3"><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.apply_chords.html">porespy.filters.apply_chords</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.apply_chords_3D.html">porespy.filters.apply_chords_3D</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.apply_padded.html">porespy.filters.apply_padded</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.chunked_func.html">porespy.filters.chunked_func</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.distance_transform_lin.html">porespy.filters.distance_transform_lin</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.fftmorphology.html">porespy.filters.fftmorphology</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.fill_blind_pores.html">porespy.filters.fill_blind_pores</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.find_disconnected_voxels.html">porespy.filters.find_disconnected_voxels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.find_dt_artifacts.html">porespy.filters.find_dt_artifacts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.find_peaks.html">porespy.filters.find_peaks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.flood.html">porespy.filters.flood</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.hold_peaks.html">porespy.filters.hold_peaks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.local_thickness.html">porespy.filters.local_thickness</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.nphase_border.html">porespy.filters.nphase_border</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.porosimetry.html">porespy.filters.porosimetry</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.prune_branches.html">porespy.filters.prune_branches</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.reduce_peaks.html">porespy.filters.reduce_peaks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.region_size.html">porespy.filters.region_size</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.snow_partitioning.html">porespy.filters.snow_partitioning</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.snow_partitioning_n.html">porespy.filters.snow_partitioning_n</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.snow_partitioning_parallel.html">porespy.filters.snow_partitioning_parallel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.trim_disconnected_blobs.html">porespy.filters.trim_disconnected_blobs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.trim_extrema.html">porespy.filters.trim_extrema</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.trim_floating_solid.html">porespy.filters.trim_floating_solid</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.trim_nearby_peaks.html">porespy.filters.trim_nearby_peaks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.trim_nonpercolating_paths.html">porespy.filters.trim_nonpercolating_paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.trim_saddle_points.html">porespy.filters.trim_saddle_points</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.filters.trim_small_clusters.html">porespy.filters.trim_small_clusters</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../modules/metrics.html">Metrics</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label for="toctree-checkbox-4"><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.metrics.chord_counts.html">porespy.metrics.chord_counts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.metrics.chord_length_distribution.html">porespy.metrics.chord_length_distribution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.metrics.lineal_path_distribution.html">porespy.metrics.lineal_path_distribution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.metrics.mesh_surface_area.html">porespy.metrics.mesh_surface_area</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.metrics.phase_fraction.html">porespy.metrics.phase_fraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.metrics.pore_size_distribution.html">porespy.metrics.pore_size_distribution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.metrics.porosity.html">porespy.metrics.porosity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.metrics.porosity_profile.html">porespy.metrics.porosity_profile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.metrics.prop_to_image.html">porespy.metrics.prop_to_image</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.metrics.props_to_DataFrame.html">porespy.metrics.props_to_DataFrame</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.metrics.radial_density_distribution.html">porespy.metrics.radial_density_distribution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.metrics.region_interface_areas.html">porespy.metrics.region_interface_areas</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.metrics.region_surface_areas.html">porespy.metrics.region_surface_areas</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.metrics.regionprops_3D.html">porespy.metrics.regionprops_3D</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.metrics.representative_elementary_volume.html">porespy.metrics.representative_elementary_volume</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.metrics.two_point_correlation_bf.html">porespy.metrics.two_point_correlation_bf</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.metrics.two_point_correlation_fft.html">porespy.metrics.two_point_correlation_fft</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../modules/networks.html">Networks</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label for="toctree-checkbox-5"><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.networks.snow.html">porespy.networks.snow</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.networks.snow_dual.html">porespy.networks.snow_dual</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.networks.map_to_regions.html">porespy.networks.map_to_regions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.networks.regions_to_network.html">porespy.networks.regions_to_network</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.networks.add_boundary_regions.html">porespy.networks.add_boundary_regions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.networks.generate_voxel_image.html">porespy.networks.generate_voxel_image</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.networks.maximal_ball.html">porespy.networks.maximal_ball</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../modules/dns.html">DNS</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label for="toctree-checkbox-6"><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.dns.tortuosity.html">porespy.dns.tortuosity</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../modules/tools.html">Tools</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label for="toctree-checkbox-7"><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.align_image_with_openpnm.html">porespy.tools.align_image_with_openpnm</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.bbox_to_slices.html">porespy.tools.bbox_to_slices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.extend_slice.html">porespy.tools.extend_slice</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.extract_subsection.html">porespy.tools.extract_subsection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.extract_regions.html">porespy.tools.extract_regions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.extract_cylinder.html">porespy.tools.extract_cylinder</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.extract_subsection.html">porespy.tools.extract_subsection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.fftmorphology.html">porespy.tools.fftmorphology</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.find_outer_region.html">porespy.tools.find_outer_region</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.get_border.html">porespy.tools.get_border</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.get_planes.html">porespy.tools.get_planes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.insert_cylinder.html">porespy.tools.insert_cylinder</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.insert_sphere.html">porespy.tools.insert_sphere</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.in_hull.html">porespy.tools.in_hull</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.make_contiguous.html">porespy.tools.make_contiguous</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.mesh_region.html">porespy.tools.mesh_region</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.norm_to_uniform.html">porespy.tools.norm_to_uniform</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.overlay.html">porespy.tools.overlay</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.ps_ball.html">porespy.tools.ps_ball</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.ps_disk.html">porespy.tools.ps_disk</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.ps_rect.html">porespy.tools.ps_rect</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.ps_round.html">porespy.tools.ps_round</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.pad_faces.html">porespy.tools.pad_faces</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.randomize_colors.html">porespy.tools.randomize_colors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.seq_to_satn.html">porespy.tools.seq_to_satn</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.size_to_seq.html">porespy.tools.size_to_seq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.subdivide.html">porespy.tools.subdivide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.tools.zero_corners.html">porespy.tools.zero_corners</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../modules/visualization.html">Visualization</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label for="toctree-checkbox-8"><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.visualization.sem.html">porespy.visualization.sem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.visualization.show_planes.html">porespy.visualization.show_planes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.visualization.xray.html">porespy.visualization.xray</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.visualization.show_3D.html">porespy.visualization.show_3D</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.visualization.imshow.html">porespy.visualization.imshow</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.visualization.bar.html">porespy.visualization.bar</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.visualization.show_mesh.html">porespy.visualization.show_mesh</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.visualization.set_mpl_style.html">porespy.visualization.set_mpl_style</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../modules/io.html">IO</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label for="toctree-checkbox-9"><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.io.to_vtk.html">porespy.io.to_vtk</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.io.dict_to_vtk.html">porespy.io.dict_to_vtk</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.io.to_palabos.html">porespy.io.to_palabos</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.io.openpnm_to_im.html">porespy.io.openpnm_to_im</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.io.to_stl.html">porespy.io.to_stl</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.io.to_paraview.html">porespy.io.to_paraview</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.io.open_paraview.html">porespy.io.open_paraview</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/generated/porespy.io.spheres_to_comsol.html">porespy.io.spheres_to_comsol</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_guide.html">PoreSpy</a></li>
</ul>

</div>
</div>
      </div>
      
    </div>
  </aside>
  <main class="main">
    <div class="content">
      <article role="main">
        <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
          <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
        </label>
        <h1>Source code for porespy.filters.__funcs__</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">dask</span>
<span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">njit</span><span class="p">,</span> <span class="n">prange</span>
<span class="kn">from</span> <span class="nn">edt</span> <span class="kn">import</span> <span class="n">edt</span>
<span class="kn">import</span> <span class="nn">operator</span> <span class="k">as</span> <span class="nn">op</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">spim</span>
<span class="kn">import</span> <span class="nn">scipy.spatial</span> <span class="k">as</span> <span class="nn">sptl</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">reconstruction</span>
<span class="kn">from</span> <span class="nn">skimage.segmentation</span> <span class="kn">import</span> <span class="n">clear_border</span><span class="p">,</span> <span class="n">watershed</span>
<span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">ball</span><span class="p">,</span> <span class="n">disk</span><span class="p">,</span> <span class="n">square</span><span class="p">,</span> <span class="n">cube</span><span class="p">,</span> <span class="n">diamond</span><span class="p">,</span> <span class="n">octahedron</span>
<span class="kn">from</span> <span class="nn">porespy.tools</span> <span class="kn">import</span> <span class="n">_check_for_singleton_axes</span>
<span class="kn">from</span> <span class="nn">porespy.tools</span> <span class="kn">import</span> <span class="n">randomize_colors</span><span class="p">,</span> <span class="n">fftmorphology</span>
<span class="kn">from</span> <span class="nn">porespy.tools</span> <span class="kn">import</span> <span class="n">get_border</span><span class="p">,</span> <span class="n">extend_slice</span><span class="p">,</span> <span class="n">extract_subsection</span>
<span class="kn">from</span> <span class="nn">porespy.tools</span> <span class="kn">import</span> <span class="n">_create_alias_map</span>
<span class="kn">from</span> <span class="nn">porespy.tools</span> <span class="kn">import</span> <span class="n">ps_disk</span><span class="p">,</span> <span class="n">ps_ball</span>
<span class="kn">from</span> <span class="nn">porespy</span> <span class="kn">import</span> <span class="n">settings</span>
<span class="kn">from</span> <span class="nn">porespy.tools</span> <span class="kn">import</span> <span class="n">get_tqdm</span>
<span class="kn">from</span> <span class="nn">loguru</span> <span class="kn">import</span> <span class="n">logger</span>
<span class="n">tqdm</span> <span class="o">=</span> <span class="n">get_tqdm</span><span class="p">()</span>


<div class="viewcode-block" id="apply_padded"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.apply_padded.html#porespy.filters.apply_padded">[docs]</a><span class="k">def</span> <span class="nf">apply_padded</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">pad_val</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Applies padding to an image before sending to ``func``, then extracts</span>
<span class="sd">    the result corresponding to the original image shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        The image to which ``func`` should be applied</span>
<span class="sd">    pad_width : int or list of ints</span>
<span class="sd">        The amount of padding to apply to each axis. Refer to</span>
<span class="sd">        ``numpy.pad`` documentation for more details.</span>
<span class="sd">    pad_val : scalar</span>
<span class="sd">        The value to place into the padded voxels.  The default is 1 (or</span>
<span class="sd">        ``True``) which extends the pore space.</span>
<span class="sd">    func : function handle</span>
<span class="sd">        The function to apply to the padded image.</span>
<span class="sd">    kwargs</span>
<span class="sd">        Additional keyword arguments are collected and passed to ``func``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A use case for this is when using ``skimage.morphology.skeletonize_3d``</span>
<span class="sd">    to ensure that the skeleton extends beyond the edges of the image.</span>

<span class="sd">    """</span>
    <span class="n">padded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="n">pad_width</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="s1">'constant'</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="n">pad_val</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">padded</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">extract_subsection</span><span class="p">(</span><span class="n">im</span><span class="o">=</span><span class="n">temp</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="trim_small_clusters"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.trim_small_clusters.html#porespy.filters.trim_small_clusters">[docs]</a><span class="k">def</span> <span class="nf">trim_small_clusters</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Remove isolated voxels or clusters of a given size or smaller.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        The binary image from which voxels are to be removed.</span>
<span class="sd">    size : scalar</span>
<span class="sd">        The threshold size of clusters to trim.  As clusters with this</span>
<span class="sd">        many voxels or fewer will be trimmed.  The default is 1 so only</span>
<span class="sd">        single voxels are removed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        A copy of ``im`` with clusters of voxels smaller than the given</span>
<span class="sd">        ``size`` removed.</span>

<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">strel</span> <span class="o">=</span> <span class="n">disk</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">strel</span> <span class="o">=</span> <span class="n">ball</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"Only 2D or 3D images are accepted"</span><span class="p">)</span>
    <span class="n">filtered_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">labels</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">filtered_array</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">strel</span><span class="p">)</span>
    <span class="n">id_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spim</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="n">area_mask</span> <span class="o">=</span> <span class="n">id_sizes</span> <span class="o">&lt;=</span> <span class="n">size</span>
    <span class="n">filtered_array</span><span class="p">[</span><span class="n">area_mask</span><span class="p">[</span><span class="n">labels</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">filtered_array</span></div>


<div class="viewcode-block" id="hold_peaks"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.hold_peaks.html#porespy.filters.hold_peaks">[docs]</a><span class="k">def</span> <span class="nf">hold_peaks</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Replaces each voxel with the highest value along the given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        A greyscale image whose peaks are to be found.</span>
<span class="sd">    axis : int</span>
<span class="sd">        The axis along which the operation is to be applied.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : ND-array</span>
<span class="sd">        A copy of ``im`` with each voxel is replaced with the highest value along</span>
<span class="sd">        the given axis.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    "im" must be a greyscale image. In case a Boolean image is fed into this</span>
<span class="sd">    method, it will be first converted to float values [0.0,1.0] before proceeding.</span>

<span class="sd">    """</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">updown</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="o">*</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">B</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">updown</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">updown</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">B</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">updown</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">chnidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">updown</span><span class="p">)</span>
    <span class="n">chng</span> <span class="o">=</span> <span class="n">updown</span><span class="p">[</span><span class="n">chnidx</span><span class="p">]</span>
    <span class="p">(</span><span class="n">pkidx</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">chng</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">chng</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">chnidx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">pkidx</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="n">pkidx</span><span class="p">),</span> <span class="n">chnidx</span><span class="p">),)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">aux</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">aux</span><span class="p">[(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)),</span> <span class="n">pkidx</span><span class="p">),)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">pkidx</span><span class="p">])</span>
    <span class="n">aux</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="distance_transform_lin"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.distance_transform_lin.html#porespy.filters.distance_transform_lin">[docs]</a><span class="k">def</span> <span class="nf">distance_transform_lin</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"both"</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Replaces each void voxel with the linear distance to the nearest solid</span>
<span class="sd">    voxel along the specified axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        The image of the porous material with ``True`` values indicating</span>
<span class="sd">        the void phase (or phase of interest).</span>
<span class="sd">    axis : int</span>
<span class="sd">        The direction along which the distance should be measured, the</span>
<span class="sd">        default is 0 (i.e. along the x-direction).</span>
<span class="sd">    mode : str</span>
<span class="sd">        Controls how the distance is measured. Options are:</span>
<span class="sd">          - 'forward': Distances are measured in the increasing direction</span>
<span class="sd">            along the specified axis</span>
<span class="sd">          - 'reverse': Distances are measured in the reverse direction.</span>
<span class="sd">            'backward' is also accepted.</span>
<span class="sd">          - 'both': Distances are calculated in both directions (by</span>
<span class="sd">            recursively calling itself), then reporting the minimum value</span>
<span class="sd">            of the two results.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A copy of ``im`` with each foreground voxel containing the</span>
<span class="sd">        distance to the nearest background along the specified axis.</span>

<span class="sd">    """</span>
    <span class="n">_check_for_singleton_axes</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"backward"</span><span class="p">,</span> <span class="s2">"reverse"</span><span class="p">]:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">distance_transform_lin</span><span class="p">(</span><span class="n">im</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"forward"</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">im</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"both"</span><span class="p">]:</span>
        <span class="n">im_f</span> <span class="o">=</span> <span class="n">distance_transform_lin</span><span class="p">(</span><span class="n">im</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"forward"</span><span class="p">)</span>
        <span class="n">im_b</span> <span class="o">=</span> <span class="n">distance_transform_lin</span><span class="p">(</span><span class="n">im</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"backward"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">im_f</span><span class="p">,</span> <span class="n">im_b</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">im</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="n">im</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"constant"</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]]</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"constant"</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
        <span class="p">]</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"constant"</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">im</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">e</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span></div>


<div class="viewcode-block" id="snow_partitioning"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.snow_partitioning.html#porespy.filters.snow_partitioning">[docs]</a><span class="k">def</span> <span class="nf">snow_partitioning</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">r_max</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">return_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">randomize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Partitions the void space into pore regions using a marker-based</span>
<span class="sd">    watershed algorithm, with specially filtered peaks as markers.</span>

<span class="sd">    The SNOW network extraction algorithm (Sub-Network of an</span>
<span class="sd">    Over-segmented Watershed) was designed to handle to perculiarities of</span>
<span class="sd">    high porosity materials, but it applies well to other materials as</span>
<span class="sd">    well.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : array_like</span>
<span class="sd">        A boolean image of the domain, with ``True`` indicating the pore</span>
<span class="sd">        space and ``False`` elsewhere.</span>
<span class="sd">    dt : array_like, optional</span>
<span class="sd">        The distance transform of the pore space.  This is done</span>
<span class="sd">        automatically if not provided, but if the distance transform has</span>
<span class="sd">        already been computed then supplying it can save some time.</span>
<span class="sd">    r_max : int</span>
<span class="sd">        The radius of the spherical structuring element to use in the</span>
<span class="sd">        Maximum filter stage that is used to find peaks. The default is 4.</span>
<span class="sd">    sigma : float</span>
<span class="sd">        The standard deviation of the Gaussian filter used in step 1. The</span>
<span class="sd">        default is 0.4.  If 0 is given then the filter is not applied,</span>
<span class="sd">        which is useful if a distance transform is supplied as the ``im``</span>
<span class="sd">        argument that has already been processed.</span>
<span class="sd">    return_all : boolean</span>
<span class="sd">        If set to ``True`` a named tuple is returned containing the</span>
<span class="sd">        original image, the distance transform, the filtered peaks, and</span>
<span class="sd">        the final pore regions.  The default is ``False``.</span>
<span class="sd">    mask : boolean</span>
<span class="sd">        Apply a mask to the regions where the solid phase is. Default is</span>
<span class="sd">        ``True``</span>
<span class="sd">    randomize : boolean</span>
<span class="sd">        If ``True`` (default), then the region colors will be randomized</span>
<span class="sd">        before returning.  This is helpful for visualizing otherwise</span>
<span class="sd">        neighboring regions have simlar coloring are are hard to</span>
<span class="sd">        distinguish.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        An image the same shape as ``im`` with the void space partitioned</span>
<span class="sd">        into pores using a marker based watershed with the peaks found by</span>
<span class="sd">        the SNOW algorithm [1].</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If ``return_all`` is ``True`` then a **named tuple** is returned</span>
<span class="sd">    containing all of the images used during the process.  They can be</span>
<span class="sd">    access as attriutes with the following names:</span>

<span class="sd">    - ``im``: The binary image of the void space</span>
<span class="sd">    - ``dt``: The distance transform of the image</span>
<span class="sd">    - ``peaks``: The peaks of the distance transform after applying the</span>
<span class="sd">      steps of the SNOW algorithm</span>
<span class="sd">    - ``regions``: The void space partitioned into pores using a marker</span>
<span class="sd">      based watershed with the peaks found by the SNOW algorithm</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Gostick, J. "A versatile and efficient network extraction algorithm</span>
<span class="sd">    using marker-based watershed segmenation".  Physical Review E. (2017)</span>

<span class="sd">    """</span>
    <span class="n">tup</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">"results"</span><span class="p">,</span> <span class="n">field_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"im"</span><span class="p">,</span> <span class="s2">"dt"</span><span class="p">,</span> <span class="s2">"peaks"</span><span class="p">,</span> <span class="s2">"regions"</span><span class="p">])</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s2">"Beginning SNOW algorithm"</span><span class="p">)</span>
    <span class="n">im_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s2">"Converting supplied image to boolean"</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">im</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s2">"Peforming distance transform"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">im_shape</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">im_shape</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">edt</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">edt</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>

    <span class="n">tup</span><span class="o">.</span><span class="n">im</span> <span class="o">=</span> <span class="n">im</span>
    <span class="n">tup</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span>

    <span class="k">if</span> <span class="n">sigma</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Applying Gaussian blur with sigma = </span><span class="si">{</span><span class="n">sigma</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>

    <span class="n">peaks</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">r_max</span><span class="o">=</span><span class="n">r_max</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Initial number of peaks: </span><span class="si">{</span><span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">peaks</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">trim_saddle_points</span><span class="p">(</span><span class="n">peaks</span><span class="o">=</span><span class="n">peaks</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">max_iters</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Peaks after trimming saddle points: </span><span class="si">{</span><span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">peaks</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">trim_nearby_peaks</span><span class="p">(</span><span class="n">peaks</span><span class="o">=</span><span class="n">peaks</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">peaks</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Peaks after trimming nearby peaks: </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="n">tup</span><span class="o">.</span><span class="n">peaks</span> <span class="o">=</span> <span class="n">peaks</span>
    <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
        <span class="n">mask_solid</span> <span class="o">=</span> <span class="n">im</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask_solid</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">regions</span> <span class="o">=</span> <span class="n">watershed</span><span class="p">(</span><span class="n">image</span><span class="o">=-</span><span class="n">dt</span><span class="p">,</span> <span class="n">markers</span><span class="o">=</span><span class="n">peaks</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask_solid</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">randomize</span><span class="p">:</span>
        <span class="n">regions</span> <span class="o">=</span> <span class="n">randomize_colors</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_all</span><span class="p">:</span>
        <span class="n">tup</span><span class="o">.</span><span class="n">regions</span> <span class="o">=</span> <span class="n">regions</span>
        <span class="k">return</span> <span class="n">tup</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">regions</span></div>


<div class="viewcode-block" id="snow_partitioning_n"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.snow_partitioning_n.html#porespy.filters.snow_partitioning_n">[docs]</a><span class="k">def</span> <span class="nf">snow_partitioning_n</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">r_max</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">return_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">randomize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    This function partitions an imaging oontain an arbitrary number of</span>
<span class="sd">    phases into regions using a marker-based watershed segmentation. Its</span>
<span class="sd">    an extension of snow_partitioning function with all phases partitioned</span>
<span class="sd">    together.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        Image of porous material where each phase is represented by unique</span>
<span class="sd">        integer starting from 1 (0's are ignored).</span>
<span class="sd">    r_max : scalar</span>
<span class="sd">        The radius of the spherical structuring element to use in the</span>
<span class="sd">        Maximum filter stage that is used to find peaks. The default is 4.</span>
<span class="sd">    sigma : scalar</span>
<span class="sd">        The standard deviation of the Gaussian filter used. The default is</span>
<span class="sd">        0.4. If 0 is given then the filter is not applied, which is useful</span>
<span class="sd">        if a distance transform is supplied as the ``im`` argument that</span>
<span class="sd">        has already been processed.</span>
<span class="sd">    return_all : boolean (default is False)</span>
<span class="sd">        If set to ``True`` a named tuple is returned containing the</span>
<span class="sd">        original image, the combined distance transform, list of each</span>
<span class="sd">        phase max label, and the final combined regions of all phases.</span>
<span class="sd">    mask : boolean (default is True)</span>
<span class="sd">        Apply a mask to the regions which are not under concern.</span>
<span class="sd">    randomize : boolean</span>
<span class="sd">        If ``True`` (default), then the region colors will be randomized</span>
<span class="sd">        before returning.  This is helpful for visualizing otherwise</span>
<span class="sd">        neighboring regions have similar coloring and are hard to</span>
<span class="sd">        distinguish.</span>
<span class="sd">    alias : dict (Optional)</span>
<span class="sd">        A dictionary that assigns unique image label to specific phases.</span>
<span class="sd">        For example {1: 'Solid'} will show all structural properties</span>
<span class="sd">        associated with label 1 as Solid phase properties. If ``None``</span>
<span class="sd">        then default labelling will be used i.e {1: 'Phase1',..}.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    An image the same shape as ``im`` with the all phases partitioned into</span>
<span class="sd">    regions using a marker based watershed with the peaks found by the</span>
<span class="sd">    SNOW algorithm [1].  If ``return_all`` is ``True`` then a</span>
<span class="sd">    **named tuple** is returned with the following attribute:</span>

<span class="sd">    - ``im`` : The actual image of the porous material</span>
<span class="sd">    - ``dt`` : The combined distance transform of the image</span>
<span class="sd">    - ``phase_max_label`` : The list of max label of each phase in order to</span>
<span class="sd">      distinguish between each other</span>
<span class="sd">    - ``regions`` : The partitioned regions of n phases using a marker</span>
<span class="sd">      based watershed with the peaks found by the SNOW algorithm</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Gostick, J. "A versatile and efficient network extraction</span>
<span class="sd">    algorithm using marker-based watershed segmentation".  Physical Review</span>
<span class="sd">    E. (2017)</span>

<span class="sd">    [2] Khan, ZA et al. "Dual network extraction algorithm to investigate</span>
<span class="sd">    multiple transport processes in porous materials: Image-based modeling</span>
<span class="sd">    of pore and grain-scale processes". Computers in Chemical Engineering.</span>
<span class="sd">    (2019)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    snow_partitioning</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In principle it is possible to perform a distance transform on each</span>
<span class="sd">    phase separately, merge these into a single image, then apply the</span>
<span class="sd">    watershed only once. This, however, has been found to create edge</span>
<span class="sd">    artifacts between regions arising from the way watershed handles</span>
<span class="sd">    plateaus in the distance transform. To overcome this, this function</span>
<span class="sd">    applies the watershed to each of the distance transforms separately,</span>
<span class="sd">    then merges the segmented regions back into a single image.</span>

<span class="sd">    """</span>
    <span class="c1"># Get alias if provided by user</span>
    <span class="n">al</span> <span class="o">=</span> <span class="n">_create_alias_map</span><span class="p">(</span><span class="n">im</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">)</span>
    <span class="c1"># Perform snow on each phase and merge all segmentation and dt together</span>
    <span class="n">phases_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">im</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">phases_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">(</span><span class="n">phases_num</span><span class="p">)</span>
    <span class="n">combined_dt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">combined_region</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">num</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">phases_num</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">alias</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Processing Phase </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Processing Phase </span><span class="si">{</span><span class="n">al</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="n">phase_snow</span> <span class="o">=</span> <span class="n">snow_partitioning</span><span class="p">(</span>
            <span class="n">im</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span>
            <span class="n">dt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">r_max</span><span class="o">=</span><span class="n">r_max</span><span class="p">,</span>
            <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
            <span class="n">return_all</span><span class="o">=</span><span class="n">return_all</span><span class="p">,</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
            <span class="n">randomize</span><span class="o">=</span><span class="n">randomize</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">combined_dt</span> <span class="o">+=</span> <span class="n">phase_snow</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">phase_snow</span><span class="o">.</span><span class="n">regions</span> <span class="o">*=</span> <span class="n">phase_snow</span><span class="o">.</span><span class="n">im</span>
        <span class="n">phase_snow</span><span class="o">.</span><span class="n">regions</span> <span class="o">+=</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">phase_ws</span> <span class="o">=</span> <span class="n">phase_snow</span><span class="o">.</span><span class="n">regions</span> <span class="o">*</span> <span class="n">phase_snow</span><span class="o">.</span><span class="n">im</span>
        <span class="n">phase_ws</span><span class="p">[</span><span class="n">phase_ws</span> <span class="o">==</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">combined_region</span> <span class="o">+=</span> <span class="n">phase_ws</span>
        <span class="n">num</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">combined_region</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">return_all</span><span class="p">:</span>
        <span class="n">tup</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span>
            <span class="s2">"results"</span><span class="p">,</span> <span class="n">field_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"im"</span><span class="p">,</span> <span class="s2">"dt"</span><span class="p">,</span> <span class="s2">"phase_max_label"</span><span class="p">,</span> <span class="s2">"regions"</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">tup</span><span class="o">.</span><span class="n">im</span> <span class="o">=</span> <span class="n">im</span>
        <span class="n">tup</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">combined_dt</span>
        <span class="n">tup</span><span class="o">.</span><span class="n">phase_max_label</span> <span class="o">=</span> <span class="n">num</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">tup</span><span class="o">.</span><span class="n">regions</span> <span class="o">=</span> <span class="n">combined_region</span>
        <span class="k">return</span> <span class="n">tup</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">combined_region</span></div>


<div class="viewcode-block" id="find_peaks"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.find_peaks.html#porespy.filters.find_peaks">[docs]</a><span class="k">def</span> <span class="nf">find_peaks</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">r_max</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Finds local maxima in the distance transform</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dt : ndarray</span>
<span class="sd">        The distance transform of the pore space.  This may be calculated</span>
<span class="sd">        and filtered using any means desired.</span>
<span class="sd">    r_max : scalar</span>
<span class="sd">        The size of the structuring element used in the maximum filter.</span>
<span class="sd">        This controls the localness of any maxima. The default is 4 voxels.</span>
<span class="sd">    footprint : ND-array</span>
<span class="sd">        Specifies the shape of the structuring element used to define the</span>
<span class="sd">        neighborhood when looking for peaks.  If ``None`` (the default) is</span>
<span class="sd">        specified then a spherical shape is used (or circular in 2D).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        An array of booleans with ``True`` values at the location of any</span>
<span class="sd">        local maxima.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    It is also possible ot the ``peak_local_max`` function from the</span>
<span class="sd">    ``skimage.feature`` module as follows:</span>

<span class="sd">    ``peaks = peak_local_max(image=dt, min_distance=r, exclude_border=0,</span>
<span class="sd">    indices=False)``</span>

<span class="sd">    The *skimage* function automatically uses a square structuring element</span>
<span class="sd">    which is significantly faster than using a circular or spherical</span>
<span class="sd">    element.</span>

<span class="sd">    """</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">_check_for_singleton_axes</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">footprint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">footprint</span> <span class="o">=</span> <span class="n">disk</span>
        <span class="k">elif</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">footprint</span> <span class="o">=</span> <span class="n">ball</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"Only 2d and 3d images are supported"</span><span class="p">)</span>
    <span class="n">parallel</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'parallel'</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">cores</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'cores'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">divs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'cores'</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">footprint</span><span class="p">(</span><span class="n">r_max</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">chunked_func</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">find_peaks</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
                             <span class="n">im_arg</span><span class="o">=</span><span class="s1">'dt'</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="n">footprint</span><span class="p">,</span>
                             <span class="n">cores</span><span class="o">=</span><span class="n">cores</span><span class="p">,</span> <span class="n">divs</span><span class="o">=</span><span class="n">divs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">maximum_filter</span><span class="p">(</span><span class="n">dt</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="o">~</span><span class="n">im</span><span class="p">),</span> <span class="n">footprint</span><span class="o">=</span><span class="n">footprint</span><span class="p">(</span><span class="n">r_max</span><span class="p">))</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="p">(</span><span class="n">dt</span> <span class="o">==</span> <span class="n">mx</span><span class="p">)</span> <span class="o">*</span> <span class="n">im</span>
    <span class="k">return</span> <span class="n">peaks</span></div>


<div class="viewcode-block" id="reduce_peaks"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.reduce_peaks.html#porespy.filters.reduce_peaks">[docs]</a><span class="k">def</span> <span class="nf">reduce_peaks</span><span class="p">(</span><span class="n">peaks</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Any peaks that are broad or elongated are replaced with a single voxel</span>
<span class="sd">    that is located at the center of mass of the original voxels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    peaks : ND-image</span>
<span class="sd">        An image containing ``True`` values indicating peaks in the</span>
<span class="sd">        distance transform</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ND-array</span>
<span class="sd">        An array with the same number of isolated peaks as the original</span>
<span class="sd">        image, but fewer total ``True`` voxels.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The center of mass of a group of voxels is used as the new single</span>
<span class="sd">    voxel, so if the group has an odd shape (like a horse shoe), the new</span>
<span class="sd">    voxel may *not* lie on top of the original set.</span>

<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">peaks</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">strel</span> <span class="o">=</span> <span class="n">square</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">strel</span> <span class="o">=</span> <span class="n">cube</span>
    <span class="n">markers</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">peaks</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">strel</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">measurements</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span>
        <span class="nb">input</span><span class="o">=</span><span class="n">peaks</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">markers</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># Centroid may not be on old pixel, so create a new peaks image</span>
    <span class="n">peaks_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">peaks_new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">inds</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">peaks_new</span></div>


<div class="viewcode-block" id="trim_saddle_points"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.trim_saddle_points.html#porespy.filters.trim_saddle_points">[docs]</a><span class="k">def</span> <span class="nf">trim_saddle_points</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">max_iters</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Removes peaks that were mistakenly identified because they lied on a</span>
<span class="sd">    saddle or ridge in the distance transform that was not actually a true</span>
<span class="sd">    local peak.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    peaks : ndarray</span>
<span class="sd">        A boolean image containing True values to mark peaks in the</span>
<span class="sd">        distance transform (``dt``)</span>

<span class="sd">    dt : ndarray</span>
<span class="sd">        The distance transform of the pore space for which the true peaks</span>
<span class="sd">        are sought.</span>

<span class="sd">    max_iters : int</span>
<span class="sd">        The maximum number of iterations to run while eroding the saddle</span>
<span class="sd">        points.  The default is 10, which is usually not reached; however,</span>
<span class="sd">        a warning is issued if the loop ends prior to removing all saddle</span>
<span class="sd">        points.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ND-array</span>
<span class="sd">        An image with fewer peaks than the input image</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Gostick, J. "A versatile and efficient network extraction algorithm</span>
<span class="sd">    using marker-based watershed segmenation".  Physical Review E. (2017)</span>

<span class="sd">    """</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span> <span class="k">as</span> <span class="n">cube</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">cube</span>
    <span class="n">labels</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">find_objects</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">extend_slice</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">slices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="n">peaks</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">peaks_i</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">dt_i</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
        <span class="n">im_i</span> <span class="o">=</span> <span class="n">dt_i</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">iters</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">peaks_dil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">peaks_i</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">iters</span> <span class="o">&lt;</span> <span class="n">max_iters</span><span class="p">:</span>
            <span class="n">iters</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">peaks_dil</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">peaks_dil</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">cube</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
            <span class="n">peaks_max</span> <span class="o">=</span> <span class="n">peaks_dil</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">dt_i</span> <span class="o">*</span> <span class="n">peaks_dil</span><span class="p">)</span>
            <span class="n">peaks_extended</span> <span class="o">=</span> <span class="p">(</span><span class="n">peaks_max</span> <span class="o">==</span> <span class="n">dt_i</span><span class="p">)</span> <span class="o">*</span> <span class="n">im_i</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">peaks_extended</span> <span class="o">==</span> <span class="n">peaks_i</span><span class="p">):</span>
                <span class="k">break</span>  <span class="c1"># Found a true peak</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">peaks_extended</span> <span class="o">*</span> <span class="n">peaks_i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">peaks_i</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>  <span class="c1"># Found a saddle point</span>
        <span class="n">peaks</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">peaks_i</span>
        <span class="k">if</span> <span class="n">iters</span> <span class="o">&gt;=</span> <span class="n">max_iters</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">"Maximum number of iterations reached, consider"</span>
                           <span class="s2">" running again with a larger value of max_iters"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">peaks</span></div>


<div class="viewcode-block" id="trim_nearby_peaks"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.trim_nearby_peaks.html#porespy.filters.trim_nearby_peaks">[docs]</a><span class="k">def</span> <span class="nf">trim_nearby_peaks</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Finds pairs of peaks that are nearer to each other than to the solid</span>
<span class="sd">    phase, and removes the peak that is closer to the solid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    peaks : ndarray</span>
<span class="sd">        A boolean image containing True values to mark peaks in the</span>
<span class="sd">        distance transform (``dt``)</span>

<span class="sd">    dt : ndarray</span>
<span class="sd">        The distance transform of the pore space for which the true peaks</span>
<span class="sd">        are sought.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        An array the same size as ``peaks`` containing a subset of the</span>
<span class="sd">        peaks in the original image.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Each pair of peaks is considered simultaneously, so for a triplet of</span>
<span class="sd">    peaks each pair is considered.  This ensures that only the single peak</span>
<span class="sd">    that is furthest from the solid is kept.  No iteration is required.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Gostick, J. "A versatile and efficient network extraction</span>
<span class="sd">    algorithm using marker-based watershed segmenation".  Physical Review</span>
<span class="sd">    E. (2017)</span>

<span class="sd">    """</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span> <span class="k">as</span> <span class="n">cube</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">cube</span>
    <span class="n">peaks</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">cube</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">crds</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">measurements</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">peaks</span><span class="p">,</span>
                                            <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">crds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">crds</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># Convert to numpy array of ints</span>
    <span class="c1"># Get distance between each peak as a distance map</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">sptl</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">crds</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">crds</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">nearest_neighbor</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">dist_to_neighbor</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">del</span> <span class="n">temp</span><span class="p">,</span> <span class="n">tree</span>  <span class="c1"># Free-up memory</span>
    <span class="n">dist_to_solid</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">crds</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span>  <span class="c1"># Get distance to solid for each peak</span>
    <span class="n">hits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dist_to_neighbor</span> <span class="o">&lt;</span> <span class="n">dist_to_solid</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Drop peak that is closer to the solid than it's neighbor</span>
    <span class="n">drop_peaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">hits</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dist_to_solid</span><span class="p">[</span><span class="n">peak</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dist_to_solid</span><span class="p">[</span><span class="n">nearest_neighbor</span><span class="p">[</span><span class="n">peak</span><span class="p">]]:</span>
            <span class="n">drop_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">drop_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nearest_neighbor</span><span class="p">[</span><span class="n">peak</span><span class="p">])</span>
    <span class="n">drop_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">drop_peaks</span><span class="p">)</span>
    <span class="c1"># Remove peaks from image</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">find_objects</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">peaks</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">drop_peaks</span><span class="p">:</span>
        <span class="n">peaks</span><span class="p">[</span><span class="n">slices</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">peaks</span> <span class="o">&gt;</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="find_disconnected_voxels"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.find_disconnected_voxels.html#porespy.filters.find_disconnected_voxels">[docs]</a><span class="k">def</span> <span class="nf">find_disconnected_voxels</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">conn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    This identifies all pore (or solid) voxels that are not connected to</span>
<span class="sd">    the edge of the image.  This can be used to find blind pores, or</span>
<span class="sd">    remove artifacts such as solid phase voxels that are floating in space.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        A Boolean image, with True values indicating the phase for which</span>
<span class="sd">        disconnected voxels are sought.</span>
<span class="sd">    conn : int</span>
<span class="sd">        For 2D the options are 4 and 8 for square and diagonal neighbors,</span>
<span class="sd">        while for the 3D the options are 6 and 26, similarily for square</span>
<span class="sd">        and diagonal neighbors. The default is the maximum option.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        An ND-image the same size as ``im``, with True values indicating</span>
<span class="sd">        voxels of the phase of interest (i.e. True values in the original</span>
<span class="sd">        image) that are not connected to the outer edges.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        The returned array (e.g. ``holes``) be used to trim blind pores</span>
<span class="sd">        from ``im`` using: ``im[holes] = False``</span>

<span class="sd">    """</span>
    <span class="n">_check_for_singleton_axes</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">conn</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">strel</span> <span class="o">=</span> <span class="n">disk</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">conn</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">8</span><span class="p">]:</span>
            <span class="n">strel</span> <span class="o">=</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"Received conn is not valid"</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">conn</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="n">strel</span> <span class="o">=</span> <span class="n">ball</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">conn</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">26</span><span class="p">]:</span>
            <span class="n">strel</span> <span class="o">=</span> <span class="n">cube</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"Received conn is not valid"</span><span class="p">)</span>
    <span class="n">labels</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">strel</span><span class="p">)</span>
    <span class="n">holes</span> <span class="o">=</span> <span class="n">clear_border</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">holes</span></div>


<div class="viewcode-block" id="fill_blind_pores"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.fill_blind_pores.html#porespy.filters.fill_blind_pores">[docs]</a><span class="k">def</span> <span class="nf">fill_blind_pores</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">conn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Fills all pores that are not connected to the edges of the image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ND-array</span>
<span class="sd">        The image of the porous material</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ND-array</span>
<span class="sd">        A version of ``im`` but with all the disconnected pores removed.</span>
<span class="sd">    conn : int</span>
<span class="sd">        For 2D the options are 4 and 8 for square and diagonal neighbors,</span>
<span class="sd">        while for the 3D the options are 6 and 26, similarily for square</span>
<span class="sd">        and diagonal neighbors. The default is the maximum option.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    find_disconnected_voxels</span>

<span class="sd">    """</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">holes</span> <span class="o">=</span> <span class="n">find_disconnected_voxels</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">conn</span><span class="o">=</span><span class="n">conn</span><span class="p">)</span>
    <span class="n">im</span><span class="p">[</span><span class="n">holes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">im</span></div>


<div class="viewcode-block" id="trim_floating_solid"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.trim_floating_solid.html#porespy.filters.trim_floating_solid">[docs]</a><span class="k">def</span> <span class="nf">trim_floating_solid</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">conn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Removes all solid that that is not attached to the edges of the image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        The image of the porous material</span>
<span class="sd">    conn : int</span>
<span class="sd">        For 2D the options are 4 and 8 for square and diagonal neighbors,</span>
<span class="sd">        while for the 3D the options are 6 and 26, similarily for square</span>
<span class="sd">        and diagonal neighbors. The default is the maximum option.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A version of ``im`` but with all the disconnected solid removed.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    find_disconnected_voxels</span>

<span class="sd">    """</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">holes</span> <span class="o">=</span> <span class="n">find_disconnected_voxels</span><span class="p">(</span><span class="o">~</span><span class="n">im</span><span class="p">,</span> <span class="n">conn</span><span class="o">=</span><span class="n">conn</span><span class="p">)</span>
    <span class="n">im</span><span class="p">[</span><span class="n">holes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">im</span></div>


<div class="viewcode-block" id="trim_nonpercolating_paths"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.trim_nonpercolating_paths.html#porespy.filters.trim_nonpercolating_paths">[docs]</a><span class="k">def</span> <span class="nf">trim_nonpercolating_paths</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">inlets</span><span class="p">,</span> <span class="n">outlets</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Removes all nonpercolating paths between specified edges or faces</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ND-array</span>
<span class="sd">        The image of the porous material with ```True`` values indicating the</span>
<span class="sd">        phase of interest</span>
<span class="sd">    inlets : ND-image</span>
<span class="sd">        A boolean mask indicating locations of inlets, such as produced by</span>
<span class="sd">        ``porespy.generators.faces``.</span>
<span class="sd">    outlets : ND-image</span>
<span class="sd">        A boolean mask indicating locations of outlets, such as produced by</span>
<span class="sd">        ``porespy.generators.faces``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ND-array</span>
<span class="sd">        A copy of ``im`` with all the nonpercolating paths removed</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is essential when performing transport simulations on an</span>
<span class="sd">    image since image regions that do not span between the desired inlet and</span>
<span class="sd">    outlet do not contribute to the transport.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    find_disconnected_voxels</span>
<span class="sd">    trim_floating_solid</span>
<span class="sd">    trim_blind_pores</span>

<span class="sd">    """</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">im</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">IN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span> <span class="o">*</span> <span class="n">inlets</span><span class="p">)</span>
    <span class="n">OUT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span> <span class="o">*</span> <span class="n">outlets</span><span class="p">)</span>
    <span class="n">hits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">OUT</span><span class="p">))))</span>
    <span class="n">new_im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">hits</span><span class="p">[</span><span class="n">hits</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">new_im</span></div>


<div class="viewcode-block" id="trim_extrema"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.trim_extrema.html#porespy.filters.trim_extrema">[docs]</a><span class="k">def</span> <span class="nf">trim_extrema</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"maxima"</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Trims local extrema in greyscale values by a specified amount.</span>

<span class="sd">    This essentially decapitates peaks and/or floods valleys.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        The image whose extrema are to be removed</span>

<span class="sd">    h : float</span>
<span class="sd">        The height to remove from each peak or fill in each valley</span>

<span class="sd">    mode : string {'maxima' | 'minima' | 'extrema'}</span>
<span class="sd">        Specifies whether to remove maxima or minima or both</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A copy of the input image with all the peaks and/or valleys</span>
<span class="sd">        removed.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is referred to as **imhmax** or **imhmin** in Matlab.</span>

<span class="sd">    """</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">im</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"maxima"</span><span class="p">,</span> <span class="s2">"extrema"</span><span class="p">]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">im</span> <span class="o">-</span> <span class="n">h</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">"dilation"</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"minima"</span><span class="p">,</span> <span class="s2">"extrema"</span><span class="p">]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">im</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">"erosion"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="flood"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.flood.html#porespy.filters.flood">[docs]</a><span class="k">def</span> <span class="nf">flood</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">regions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"max"</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Floods/fills each region in an image with a single value based on the</span>
<span class="sd">    specific values in that region.</span>

<span class="sd">    The ``mode`` argument is used to determine how the value is calculated.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : array_like</span>
<span class="sd">        An image with isolated regions with numerical values in each voxel,</span>
<span class="sd">        and 0's elsewhere.</span>
<span class="sd">    regions : array_like</span>
<span class="sd">        An array the same shape as ``im`` with each region labeled.  If</span>
<span class="sd">        ``None`` is supplied (default) then ``scipy.ndimage.label`` is</span>
<span class="sd">        used with its default arguments.</span>
<span class="sd">    mode : string</span>
<span class="sd">        Specifies how to determine which value should be used to flood</span>
<span class="sd">        each region. Options are:</span>

<span class="sd">        - 'maximum': Floods each region with the local max in that region</span>
<span class="sd">        - 'minimum': Floods each region the local minimum in that region</span>
<span class="sd">        - 'median': Floods each region the local median in that region</span>
<span class="sd">        - 'mean': Floods each region the local mean in that region</span>
<span class="sd">        - 'size': Floods each region with the size of that region</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A copy of ``im`` with new values placed in each forground voxel</span>
<span class="sd">        based on the ``mode``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    prop_to_image</span>

<span class="sd">    """</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">im</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">regions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">labels</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="s2">"sum"</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">"size"</span> <span class="k">else</span> <span class="n">mode</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="s2">"maximum"</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">"max"</span> <span class="k">else</span> <span class="n">mode</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="s2">"minimum"</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">"min"</span> <span class="k">else</span> <span class="n">mode</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"mean"</span><span class="p">,</span> <span class="s2">"median"</span><span class="p">,</span> <span class="s2">"maximum"</span><span class="p">,</span> <span class="s2">"minimum"</span><span class="p">,</span> <span class="s2">"sum"</span><span class="p">]:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">spim</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">im_flooded</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">labels</span><span class="p">]</span>
        <span class="n">im_flooded</span> <span class="o">=</span> <span class="n">im_flooded</span> <span class="o">*</span> <span class="n">mask</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">mode</span> <span class="o">+</span> <span class="s2">" is not a recognized mode"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">im_flooded</span></div>


<div class="viewcode-block" id="find_dt_artifacts"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.find_dt_artifacts.html#porespy.filters.find_dt_artifacts">[docs]</a><span class="k">def</span> <span class="nf">find_dt_artifacts</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Finds points in a distance transform that are closer to wall than</span>
<span class="sd">    solid.</span>

<span class="sd">    These points could *potentially* be erroneously high since their</span>
<span class="sd">    distance values do not reflect the possibility that solid may have</span>
<span class="sd">    been present beyond the border of the image but lost by trimming.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dt : ndarray</span>
<span class="sd">        The distance transform of the phase of interest.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        An ndarray the same shape as ``dt`` with numerical values</span>
<span class="sd">        indicating the maximum amount of error in each volxel, which is</span>
<span class="sd">        found by subtracting the distance to nearest edge of image from</span>
<span class="sd">        the distance transform value. In other words, this is the error</span>
<span class="sd">        that would be found if there were a solid voxel lurking just</span>
<span class="sd">        beyond the nearest edge of the image.  Obviously, voxels with a</span>
<span class="sd">        value of zero have no error.</span>

<span class="sd">    """</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="n">dt_lin</span> <span class="o">=</span> <span class="n">distance_transform_lin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
                                        <span class="n">axis</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"both"</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">dt_lin</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">dt</span> <span class="o">-</span> <span class="n">temp</span><span class="p">,</span> <span class="n">a_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">a_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="region_size"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.region_size.html#porespy.filters.region_size">[docs]</a><span class="k">def</span> <span class="nf">region_size</span><span class="p">(</span><span class="n">im</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Replace each voxel with size of region to which it belongs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        Either a boolean image wtih ``True`` indicating the features of</span>
<span class="sd">        interest, in which case ``scipy.ndimage.label`` will be applied to</span>
<span class="sd">        find regions, or a greyscale image with integer values indicating</span>
<span class="sd">        regions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A copy of ``im`` with each voxel value indicating the size of the</span>
<span class="sd">        region to which it belongs.  This is particularly useful for</span>
<span class="sd">        finding chord sizes on the image produced by ``apply_chords``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    flood</span>

<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">im</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
    <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">chords</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">im</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">chords</span></div>


<div class="viewcode-block" id="apply_chords"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.apply_chords.html#porespy.filters.apply_chords">[docs]</a><span class="k">def</span> <span class="nf">apply_chords</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Adds chords to the void space in the specified direction. The chords</span>
<span class="sd">    are separated by 1 voxel plus the provided spacing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        An image of the porous material with void marked as ``True``.</span>
<span class="sd">    spacing : int</span>
<span class="sd">        Separation between chords.  The default is 1 voxel.  This can be</span>
<span class="sd">        decreased to 0, meaning that the chords all touch each other,</span>
<span class="sd">        which automatically sets to the ``label`` argument to ``True``.</span>
<span class="sd">    axis : int (default = 0)</span>
<span class="sd">        The axis along which the chords are drawn.</span>
<span class="sd">    trim_edges : bool (default = ``True``)</span>
<span class="sd">        Whether or not to remove chords that touch the edges of the image.</span>
<span class="sd">        These chords are artifically shortened, so skew the chord length</span>
<span class="sd">        distribution.</span>
<span class="sd">    label : bool (default is ``False``)</span>
<span class="sd">        If ``True`` the chords in the returned image are each given a</span>
<span class="sd">        unique label, such that all voxels lying on the same chord have</span>
<span class="sd">        the same value.  This is automatically set to ``True`` if spacing</span>
<span class="sd">        is 0, but is ``False`` otherwise.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A copy of ``im`` with non-zero values indicating the chords.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    apply_chords_3D</span>

<span class="sd">    """</span>
    <span class="n">_check_for_singleton_axes</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spacing</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"Spacing cannot be less than 0"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spacing</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">label</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># Will receive chords at end</span>
    <span class="n">slxyz</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">spacing</span> <span class="o">*</span> <span class="p">(</span><span class="n">axis</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slxyz</span><span class="p">[:</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span><span class="p">])</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>  <span class="c1"># Straight-line structuring element</span>
    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Make structuring element 3D if necessary</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">pad_width</span><span class="o">=</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                   <span class="n">mode</span><span class="o">=</span><span class="s2">"constant"</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="n">chords</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">s</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">trim_edges</span><span class="p">:</span>  <span class="c1"># Label on border chords will be set to 0</span>
        <span class="n">chords</span> <span class="o">=</span> <span class="n">clear_border</span><span class="p">(</span><span class="n">chords</span><span class="p">)</span>
    <span class="n">result</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span> <span class="o">=</span> <span class="n">chords</span>  <span class="c1"># Place chords into empty image created at top</span>
    <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>  <span class="c1"># Remove label if not requested</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="apply_chords_3D"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.apply_chords_3D.html#porespy.filters.apply_chords_3D">[docs]</a><span class="k">def</span> <span class="nf">apply_chords_3D</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Adds chords to the void space in all three principle directions. The</span>
<span class="sd">    chords are seprated by 1 voxel plus the provided spacing. Chords in</span>
<span class="sd">    the X, Y and Z directions are labelled 1, 2 and 3 resepctively.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        A 3D image of the porous material with void space marked as True.</span>
<span class="sd">    spacing : int (default = 0)</span>
<span class="sd">        Chords are automatically separed by 1 voxel on all sides, and this</span>
<span class="sd">        argument increases the separation.</span>
<span class="sd">    trim_edges : bool (default is ``True``)</span>
<span class="sd">        Whether or not to remove chords that touch the edges of the image.</span>
<span class="sd">        These chords are artifically shortened, so skew the chord length</span>
<span class="sd">        distribution</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A copy of ``im`` with values of 1 indicating x-direction chords,</span>
<span class="sd">        2 indicating y-direction chords, and 3 indicating z-direction</span>
<span class="sd">        chords.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The chords are separated by a spacing of at least 1 voxel so that</span>
<span class="sd">    tools that search for connected components, such as</span>
<span class="sd">    ``scipy.ndimage.label`` can detect individual chords.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    apply_chords</span>

<span class="sd">    """</span>
    <span class="n">_check_for_singleton_axes</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"Must be a 3D image to use this function"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spacing</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"Spacing cannot be less than 0"</span><span class="p">)</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">ch</span><span class="p">[:,</span> <span class="p">::</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">spacing</span><span class="p">,</span> <span class="p">::</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">spacing</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>   <span class="c1"># X-direction</span>
    <span class="n">ch</span><span class="p">[::</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">spacing</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">::</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">spacing</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>   <span class="c1"># Y-direction</span>
    <span class="n">ch</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">spacing</span><span class="p">,</span> <span class="mi">2</span><span class="p">::</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">spacing</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">3</span>   <span class="c1"># Z-direction</span>
    <span class="n">chords</span> <span class="o">=</span> <span class="n">ch</span> <span class="o">*</span> <span class="n">im</span>
    <span class="k">if</span> <span class="n">trim_edges</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">clear_border</span><span class="p">(</span><span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">chords</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">chords</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">*</span> <span class="n">chords</span>
    <span class="k">return</span> <span class="n">chords</span></div>


<div class="viewcode-block" id="local_thickness"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.local_thickness.html#porespy.filters.local_thickness">[docs]</a><span class="k">def</span> <span class="nf">local_thickness</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">sizes</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"hybrid"</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    For each voxel, this function calculates the radius of the largest</span>
<span class="sd">    sphere that both engulfs the voxel and fits entirely within the</span>
<span class="sd">    foreground.</span>

<span class="sd">    This is not the same as a simple distance transform, which finds the</span>
<span class="sd">    largest sphere that could be *centered* on each voxel.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        A binary image with the phase of interest set to True</span>
<span class="sd">    sizes : array_like or scalar</span>
<span class="sd">        The sizes to invade.  If a list of values of provided they are</span>
<span class="sd">        used directly. If a scalar is provided then that number of points</span>
<span class="sd">        spanning the min and max of the distance transform are used.</span>
<span class="sd">    mode : str</span>
<span class="sd">        Controls with method is used to compute the result. Options are:</span>

<span class="sd">        - 'hybrid': (default) Performs a distance tranform of the void</span>
<span class="sd">          space, thresholds to find voxels larger than ``sizes[i]``, trims</span>
<span class="sd">          the resulting mask if ``access_limitations`` is ``True``, then</span>
<span class="sd">          dilates it using the efficient fft-method to obtain the</span>
<span class="sd">          non-wetting fluid configuration.</span>
<span class="sd">        - 'dt': Same as 'hybrid', except uses a second distance transform,</span>
<span class="sd">          relative to the thresholded mask, to find the invading fluid</span>
<span class="sd">          configuration. The choice of 'dt' or 'hybrid' depends on speed,</span>
<span class="sd">          which is system and installation specific.</span>
<span class="sd">        - 'mio': Using a single morphological image opening step to obtain</span>
<span class="sd">          the invading fluid confirguration directly, *then* trims if</span>
<span class="sd">          ``access_limitations`` is ``True``. This method is not ideal and</span>
<span class="sd">          is included mostly for comparison purposes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A copy of ``im`` with the pore size values in each voxel.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    porosimetry</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The term *foreground* is used since this function can be applied to</span>
<span class="sd">    both pore space or the solid, whichever is set to ``True``.</span>

<span class="sd">    This function is identical to ``porosimetry`` with ``access_limited``</span>
<span class="sd">    set to ``False``.</span>

<span class="sd">    The way local thickness is found in PoreSpy differs from the</span>
<span class="sd">    traditional method (i.e. used in ImageJ</span>
<span class="sd">    `&lt;https://imagej.net/Local_Thickness&gt;`_). Our approach is probably</span>
<span class="sd">    slower, but it allows for the same code to be used for</span>
<span class="sd">    ``local_thickness`` and ``porosimetry``, since we can 'trim' invaded</span>
<span class="sd">    regions that are not connected to the inlets in the ``porosimetry``</span>
<span class="sd">    function. This is not needed in ``local_thickness`` however.</span>

<span class="sd">    """</span>
    <span class="n">im_new</span> <span class="o">=</span> <span class="n">porosimetry</span><span class="p">(</span><span class="n">im</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">sizes</span><span class="o">=</span><span class="n">sizes</span><span class="p">,</span> <span class="n">access_limited</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">im_new</span></div>


<div class="viewcode-block" id="porosimetry"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.porosimetry.html#porespy.filters.porosimetry">[docs]</a><span class="k">def</span> <span class="nf">porosimetry</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">sizes</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">inlets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">access_limited</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'hybrid'</span><span class="p">,</span>
                <span class="n">fft</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Performs a porosimetry simulution on an image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        An ND image of the porous material containing ``True`` values in the</span>
<span class="sd">        pore space.</span>
<span class="sd">    sizes : array_like or scalar</span>
<span class="sd">        The sizes to invade.  If a list of values of provided they are</span>
<span class="sd">        used directly.  If a scalar is provided then that number of points</span>
<span class="sd">        spanning the min and max of the distance transform are used.</span>
<span class="sd">    inlets : ndarray, boolean</span>
<span class="sd">        A boolean mask with ``True`` values indicating where the invasion</span>
<span class="sd">        enters the image.  By default all faces are considered inlets,</span>
<span class="sd">        akin to a mercury porosimetry experiment.  Users can also apply</span>
<span class="sd">        solid boundaries to their image externally before passing it in,</span>
<span class="sd">        allowing for complex inlets like circular openings, etc.</span>
<span class="sd">        This argument is only used if ``access_limited`` is ``True``.</span>
<span class="sd">    access_limited : bool</span>
<span class="sd">        This flag indicates if the intrusion should only occur from the</span>
<span class="sd">        surfaces (``access_limited`` is ``True``, which is the default),</span>
<span class="sd">        or if the invading phase should be allowed to appear in the core</span>
<span class="sd">        of the image.  The former simulates experimental tools like</span>
<span class="sd">        mercury intrusion porosimetry, while the latter is useful for</span>
<span class="sd">        comparison to gauge the extent of shielding effects in the sample.</span>
<span class="sd">    mode : str</span>
<span class="sd">        Controls with method is used to compute the result. Options are:</span>
<span class="sd">          - 'hybrid': (default) Performs a distance tranform of the void</span>
<span class="sd">            space, thresholds to find voxels larger than ``sizes[i]``,</span>
<span class="sd">            trims the resulting mask if ``access_limitations`` is ``True``,</span>
<span class="sd">            then dilates it using the efficient fft-method to obtain the</span>
<span class="sd">            non-wetting fluid configuration.</span>
<span class="sd">          - 'dt': Same as 'hybrid', except uses a second distance</span>
<span class="sd">            transform, relative to the thresholded mask, to find the</span>
<span class="sd">            invading fluid configuration. The choice of 'dt' or 'hybrid'</span>
<span class="sd">            depends on speed, which is system and installation specific.</span>
<span class="sd">          - 'mio': Using a single morphological image opening step to</span>
<span class="sd">            obtain the invading fluid confirguration directly, *then* trims</span>
<span class="sd">            if ``access_limitations`` is ``True``.  This method is not</span>
<span class="sd">            ideal and is included mostly for comparison purposes. The</span>
<span class="sd">            morphological operations are done using fft-based method</span>
<span class="sd">            implementations.</span>
<span class="sd">    fft : boolean (default is ``True``)</span>
<span class="sd">        Indicates whether to use the ``fftmorphology`` function in</span>
<span class="sd">        ``porespy.filters`` or to use the standard morphology functions in</span>
<span class="sd">        ``scipy.ndimage``.  Always use ``fft=True`` unless you have a good</span>
<span class="sd">        reason not to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A copy of ``im`` with voxel values indicating the sphere radius at</span>
<span class="sd">        which it becomes accessible from the inlets.  This image can be</span>
<span class="sd">        used to find invading fluid configurations as a function of</span>
<span class="sd">        applied capillary pressure by applying a boolean comparison:</span>
<span class="sd">        ``inv_phase = im &gt; r`` where ``r`` is the radius (in voxels) of</span>
<span class="sd">        the invading sphere.  Of course, ``r`` can be converted to</span>
<span class="sd">        capillary pressure using a preferred model.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    There are many ways to perform this filter, and PoreSpy offers 3,</span>
<span class="sd">    which users can choose between via the ``mode`` argument. These</span>
<span class="sd">    methods all work in a similar way by finding which foreground voxels</span>
<span class="sd">    can accomodate a sphere of a given radius, then repeating for smaller</span>
<span class="sd">    radii.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    local_thickness</span>

<span class="sd">    """</span>
    <span class="n">_check_for_singleton_axes</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">edt</span><span class="p">(</span><span class="n">im</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">inlets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">inlets</span> <span class="o">=</span> <span class="n">get_border</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"faces"</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">dt</span><span class="p">)),</span> <span class="n">stop</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">sizes</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sizes</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">strel</span> <span class="o">=</span> <span class="n">ps_disk</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">strel</span> <span class="o">=</span> <span class="n">ps_ball</span>

    <span class="c1"># Parse kwargs for any parallelization arguments</span>
    <span class="n">parallel</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'parallel'</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">cores</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'cores'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">divs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'divs'</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">"mio"</span><span class="p">:</span>
        <span class="n">pw</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
        <span class="n">impad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"symmetric"</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="n">pw</span><span class="p">)</span>
        <span class="n">inlets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">inlets</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"symmetric"</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="n">pw</span><span class="p">)</span>
        <span class="c1"># sizes = np.unique(np.around(sizes, decimals=0).astype(int))[-1::-1]</span>
        <span class="n">imresults</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">impad</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="o">.</span><span class="n">tqdm</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
                <span class="n">imtemp</span> <span class="o">=</span> <span class="n">chunked_func</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">spim</span><span class="o">.</span><span class="n">binary_erosion</span><span class="p">,</span>
                                      <span class="nb">input</span><span class="o">=</span><span class="n">impad</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">strel</span><span class="p">(</span><span class="n">r</span><span class="p">),</span>
                                      <span class="n">overlap</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                      <span class="n">cores</span><span class="o">=</span><span class="n">cores</span><span class="p">,</span> <span class="n">divs</span><span class="o">=</span><span class="n">divs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">fft</span><span class="p">:</span>
                <span class="n">imtemp</span> <span class="o">=</span> <span class="n">fftmorphology</span><span class="p">(</span><span class="n">impad</span><span class="p">,</span> <span class="n">strel</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"erosion"</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">imtemp</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">binary_erosion</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">impad</span><span class="p">,</span>
                                             <span class="n">structure</span><span class="o">=</span><span class="n">strel</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">access_limited</span><span class="p">:</span>
                <span class="n">imtemp</span> <span class="o">=</span> <span class="n">trim_disconnected_blobs</span><span class="p">(</span><span class="n">imtemp</span><span class="p">,</span> <span class="n">inlets</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
                <span class="n">imtemp</span> <span class="o">=</span> <span class="n">chunked_func</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">spim</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">,</span>
                                      <span class="nb">input</span><span class="o">=</span><span class="n">imtemp</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">strel</span><span class="p">(</span><span class="n">r</span><span class="p">),</span>
                                      <span class="n">overlap</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                      <span class="n">cores</span><span class="o">=</span><span class="n">cores</span><span class="p">,</span> <span class="n">divs</span><span class="o">=</span><span class="n">divs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">fft</span><span class="p">:</span>
                <span class="n">imtemp</span> <span class="o">=</span> <span class="n">fftmorphology</span><span class="p">(</span><span class="n">imtemp</span><span class="p">,</span> <span class="n">strel</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"dilation"</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">imtemp</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">imtemp</span><span class="p">,</span>
                                              <span class="n">structure</span><span class="o">=</span><span class="n">strel</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">imtemp</span><span class="p">):</span>
                <span class="n">imresults</span><span class="p">[(</span><span class="n">imresults</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">imtemp</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
        <span class="n">imresults</span> <span class="o">=</span> <span class="n">extract_subsection</span><span class="p">(</span><span class="n">imresults</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">"dt"</span><span class="p">:</span>
        <span class="n">imresults</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="o">.</span><span class="n">tqdm</span><span class="p">):</span>
            <span class="n">imtemp</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">&gt;=</span> <span class="n">r</span>
            <span class="k">if</span> <span class="n">access_limited</span><span class="p">:</span>
                <span class="n">imtemp</span> <span class="o">=</span> <span class="n">trim_disconnected_blobs</span><span class="p">(</span><span class="n">imtemp</span><span class="p">,</span> <span class="n">inlets</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">imtemp</span><span class="p">):</span>
                <span class="n">imtemp</span> <span class="o">=</span> <span class="n">edt</span><span class="p">(</span><span class="o">~</span><span class="n">imtemp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">r</span>
                <span class="n">imresults</span><span class="p">[(</span><span class="n">imresults</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">imtemp</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">"hybrid"</span><span class="p">:</span>
        <span class="n">imresults</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="o">.</span><span class="n">tqdm</span><span class="p">):</span>
            <span class="n">imtemp</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">&gt;=</span> <span class="n">r</span>
            <span class="k">if</span> <span class="n">access_limited</span><span class="p">:</span>
                <span class="n">imtemp</span> <span class="o">=</span> <span class="n">trim_disconnected_blobs</span><span class="p">(</span><span class="n">imtemp</span><span class="p">,</span> <span class="n">inlets</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">imtemp</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
                    <span class="n">imtemp</span> <span class="o">=</span> <span class="n">chunked_func</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">spim</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">,</span>
                                          <span class="nb">input</span><span class="o">=</span><span class="n">imtemp</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">strel</span><span class="p">(</span><span class="n">r</span><span class="p">),</span>
                                          <span class="n">overlap</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                          <span class="n">cores</span><span class="o">=</span><span class="n">cores</span><span class="p">,</span> <span class="n">divs</span><span class="o">=</span><span class="n">divs</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">fft</span><span class="p">:</span>
                    <span class="n">imtemp</span> <span class="o">=</span> <span class="n">fftmorphology</span><span class="p">(</span><span class="n">imtemp</span><span class="p">,</span> <span class="n">strel</span><span class="p">(</span><span class="n">r</span><span class="p">),</span>
                                           <span class="n">mode</span><span class="o">=</span><span class="s2">"dilation"</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">imtemp</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">imtemp</span><span class="p">,</span>
                                                  <span class="n">structure</span><span class="o">=</span><span class="n">strel</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
                <span class="n">imresults</span><span class="p">[(</span><span class="n">imresults</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">imtemp</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"Unrecognized mode "</span> <span class="o">+</span> <span class="n">mode</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">imresults</span></div>


<div class="viewcode-block" id="trim_disconnected_blobs"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.trim_disconnected_blobs.html#porespy.filters.trim_disconnected_blobs">[docs]</a><span class="k">def</span> <span class="nf">trim_disconnected_blobs</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">inlets</span><span class="p">,</span> <span class="n">strel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Removes foreground voxels not connected to specified inlets.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        The image containing the blobs to be trimmed</span>
<span class="sd">    inlets : ndarray or tuple of indices</span>
<span class="sd">        The locations of the inlets.  Can either be a boolean mask the</span>
<span class="sd">        same shape as ``im``, or a tuple of indices such as that returned</span>
<span class="sd">        by the ``where`` function.  Any voxels *not* connected directly to</span>
<span class="sd">        the inlets will be trimmed.</span>
<span class="sd">    strel : ndarray</span>
<span class="sd">        The neighborhood over which connectivity should be checked. It</span>
<span class="sd">        must be symmetric and the same dimensionality as the image. It is</span>
<span class="sd">        passed directly to the ``scipy.ndimage.label`` function as the</span>
<span class="sd">        ``structure`` argument so refer to that docstring for additional</span>
<span class="sd">        info.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        An array of the same shape as ``im``, but with all foreground</span>
<span class="sd">        voxels not connected to the ``inlets`` removed.</span>

<span class="sd">    """</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">inlets</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">inlets</span><span class="p">)</span>
        <span class="n">inlets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">inlets</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">inlets</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">inlets</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">inlets</span> <span class="o">=</span> <span class="n">inlets</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"inlets not valid, refer to docstring for info"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">strel</span> <span class="o">=</span> <span class="n">cube</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">strel</span> <span class="o">=</span> <span class="n">square</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">inlets</span> <span class="o">+</span> <span class="p">(</span><span class="n">im</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">structure</span><span class="o">=</span><span class="n">strel</span><span class="p">(</span><span class="mi">3</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">inlets</span><span class="p">])</span>
    <span class="n">keep</span> <span class="o">=</span> <span class="n">keep</span><span class="p">[</span><span class="n">keep</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">im2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">keep</span><span class="p">),</span> <span class="n">newshape</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">im2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">im2</span> <span class="o">=</span> <span class="n">im2</span> <span class="o">*</span> <span class="n">im</span>
    <span class="k">return</span> <span class="n">im2</span></div>


<span class="k">def</span> <span class="nf">_get_axial_shifts</span><span class="p">(</span><span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">include_diagonals</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Helper function to generate the axial shifts that will be performed on</span>
<span class="sd">    the image to identify bordering pixels/voxels</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">include_diagonals</span><span class="p">:</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">diamond</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">neighbors</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">y</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">include_diagonals</span><span class="p">:</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">cube</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">octahedron</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">neighbors</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">y</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">z</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>


<span class="k">def</span> <span class="nf">_make_stack</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">include_diagonals</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Creates a stack of images with one extra dimension to the input image</span>
<span class="sd">    with length equal to the number of borders to search + 1.</span>

<span class="sd">    Image is rolled along the axial shifts so that the border pixel is</span>
<span class="sd">    overlapping the original pixel. First image in stack is the original.</span>
<span class="sd">    Stacking makes direct vectorized array comparisons possible.</span>

<span class="sd">    """</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>
    <span class="n">axial_shift</span> <span class="o">=</span> <span class="n">_get_axial_shifts</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="n">include_diagonals</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">im</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">im</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">axial_shift</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axial_shift</span><span class="p">)):</span>
            <span class="n">ax0</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">axial_shift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">ax0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ax1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
        <span class="k">return</span> <span class="n">stack</span>
    <span class="k">elif</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">im</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">im</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">im</span><span class="p">)[</span><span class="mi">2</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">axial_shift</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axial_shift</span><span class="p">)):</span>
            <span class="n">ax0</span><span class="p">,</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">axial_shift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">ax0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ax1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">ax2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
        <span class="k">return</span> <span class="n">stack</span>


<div class="viewcode-block" id="nphase_border"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.nphase_border.html#porespy.filters.nphase_border">[docs]</a><span class="k">def</span> <span class="nf">nphase_border</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">include_diagonals</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Identifies the voxels in regions that border *N* other regions.</span>

<span class="sd">    Useful for finding triple-phase boundaries.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        An ND image of the porous material containing discrete values in</span>
<span class="sd">        the pore space identifying different regions. e.g. the result of a</span>
<span class="sd">        snow-partition</span>

<span class="sd">    include_diagonals : bool</span>
<span class="sd">        When identifying bordering pixels (2D) and voxels (3D) include</span>
<span class="sd">        those shifted along more than one axis</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        A copy of ``im`` with voxel values equal to the number of uniquely</span>
<span class="sd">        different bordering values</span>

<span class="sd">    """</span>
    <span class="n">_check_for_singleton_axes</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="c1"># Get dimension of image</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"Function only works for 2d and 3d images"</span><span class="p">)</span>
    <span class="c1"># Pad image to handle edges</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"edge"</span><span class="p">)</span>
    <span class="c1"># Stack rolled images for each neighbor to be inspected</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">_make_stack</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">include_diagonals</span><span class="p">)</span>
    <span class="c1"># Sort the stack along the last axis</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="c1"># Run through stack recording when neighbor id changes</span>
    <span class="c1"># Number of changes is number of unique bordering regions</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">stack</span><span class="p">)[</span><span class="n">ndim</span><span class="p">])[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="n">mask</span>
    <span class="c1"># Un-pad</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="prune_branches"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.prune_branches.html#porespy.filters.prune_branches">[docs]</a><span class="k">def</span> <span class="nf">prune_branches</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span> <span class="n">branch_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Removes all dangling ends or tails of a skeleton.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    skel : ndarray</span>
<span class="sd">        A image of a full or partial skeleton from which the tails should</span>
<span class="sd">        be trimmed.</span>

<span class="sd">    branch_points : ndarray, optional</span>
<span class="sd">        An image the same size ``skel`` with True values indicating the</span>
<span class="sd">        branch points of the skeleton.  If this is not provided it is</span>
<span class="sd">        calculated automatically.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        An ndarray containing the skeleton with tails removed.</span>

<span class="sd">    """</span>
    <span class="n">skel</span> <span class="o">=</span> <span class="n">skel</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">skel</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span> <span class="k">as</span> <span class="n">cube</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">cube</span>
    <span class="n">parallel</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'parallel'</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">divs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'divs'</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">cores</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'cores'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="c1"># Create empty image to house results</span>
    <span class="n">im_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">skel</span><span class="p">)</span>
    <span class="c1"># If branch points are not supplied, attempt to find them</span>
    <span class="k">if</span> <span class="n">branch_points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">branch_points</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">skel</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">cube</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">3</span>
        <span class="n">branch_points</span> <span class="o">=</span> <span class="n">branch_points</span> <span class="o">*</span> <span class="n">skel</span>
    <span class="c1"># Store original branch points before dilating</span>
    <span class="n">pts_orig</span> <span class="o">=</span> <span class="n">branch_points</span>
    <span class="c1"># Find arcs of skeleton by deleting branch points</span>
    <span class="n">arcs</span> <span class="o">=</span> <span class="n">skel</span> <span class="o">*</span> <span class="p">(</span><span class="o">~</span><span class="n">branch_points</span><span class="p">)</span>
    <span class="c1"># Label arcs</span>
    <span class="n">arc_labels</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">arcs</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">cube</span><span class="p">(</span><span class="mi">3</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Dilate branch points so they overlap with the arcs</span>
    <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
        <span class="n">branch_points</span> <span class="o">=</span> <span class="n">chunked_func</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">spim</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">,</span>
                                     <span class="nb">input</span><span class="o">=</span><span class="n">branch_points</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">cube</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
                                     <span class="n">overlap</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">divs</span><span class="o">=</span><span class="n">divs</span><span class="p">,</span> <span class="n">cores</span><span class="o">=</span><span class="n">cores</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">branch_points</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">branch_points</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">cube</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">pts_labels</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">branch_points</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">cube</span><span class="p">(</span><span class="mi">3</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Now scan through each arc to see if it's connected to two branch points</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">find_objects</span><span class="p">(</span><span class="n">arc_labels</span><span class="p">)</span>
    <span class="n">label_num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">:</span>
        <span class="n">label_num</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Find branch point labels the overlap current arc</span>
        <span class="n">hits</span> <span class="o">=</span> <span class="n">pts_labels</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">arc_labels</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">==</span> <span class="n">label_num</span><span class="p">)</span>
        <span class="c1"># If image contains 2 branch points, then it's not a tail.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">hits</span><span class="p">))</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">im_result</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">arc_labels</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">==</span> <span class="n">label_num</span>
    <span class="c1"># Add missing branch points back to arc image to make complete skeleton</span>
    <span class="n">im_result</span> <span class="o">+=</span> <span class="n">skel</span> <span class="o">*</span> <span class="n">pts_orig</span>
    <span class="k">if</span> <span class="n">iterations</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">iterations</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">im_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">im_result</span><span class="p">)</span>
        <span class="n">im_result</span> <span class="o">=</span> <span class="n">prune_branches</span><span class="p">(</span><span class="n">skel</span><span class="o">=</span><span class="n">im_result</span><span class="p">,</span>
                                   <span class="n">branch_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span>
                                   <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span>
                                   <span class="n">divs</span><span class="o">=</span><span class="n">divs</span><span class="p">,</span> <span class="n">cores</span><span class="o">=</span><span class="n">cores</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">im_temp</span> <span class="o">==</span> <span class="n">im_result</span><span class="p">):</span>
            <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">im_result</span></div>


<div class="viewcode-block" id="chunked_func"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.chunked_func.html#porespy.filters.chunked_func">[docs]</a><span class="k">def</span> <span class="nf">chunked_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span>
                 <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">divs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="n">cores</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">im_arg</span><span class="o">=</span><span class="p">[</span><span class="s2">"input"</span><span class="p">,</span> <span class="s2">"image"</span><span class="p">,</span> <span class="s2">"im"</span><span class="p">],</span>
                 <span class="n">strel_arg</span><span class="o">=</span><span class="p">[</span><span class="s2">"strel"</span><span class="p">,</span> <span class="s2">"structure"</span><span class="p">,</span> <span class="s2">"footprint"</span><span class="p">],</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Performs the specfied operation "chunk-wise" in parallel using dask.</span>

<span class="sd">    This can be used to save memory by doing one chunk at a time</span>
<span class="sd">    (``cores=1``) or to increase computation speed by spreading the work</span>
<span class="sd">    across multiple cores (e.g. ``cores=8``)</span>

<span class="sd">    This function can be used with any operation that applies a</span>
<span class="sd">    structuring element of some sort, since this implies that the</span>
<span class="sd">    operation is local and can be chunked.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : function handle</span>
<span class="sd">        The function which should be applied to each chunk, such as</span>
<span class="sd">        ``spipy.ndimage.binary_dilation``.</span>
<span class="sd">    overlap : scalar or list of scalars, optional</span>
<span class="sd">        The amount of overlap to include when dividing up the image. This</span>
<span class="sd">        value will almost always be the size (i.e. diameter) of the</span>
<span class="sd">        structuring element. If not specified then the amount of overlap</span>
<span class="sd">        is inferred from the size of the structuring element, in which</span>
<span class="sd">        case the ``strel_arg`` must be specified.</span>
<span class="sd">    divs : scalar or list of scalars (default = [2, 2, 2])</span>
<span class="sd">        The number of chunks to divide the image into in each direction.</span>
<span class="sd">        The default is 2 chunks in each direction, resulting in a</span>
<span class="sd">        quartering of the image and 8 total chunks (in 3D).  A scalar is</span>
<span class="sd">        interpreted as applying to all directions, while a list of scalars</span>
<span class="sd">        is interpreted as applying to each individual direction.</span>
<span class="sd">    cores : scalar</span>
<span class="sd">        The number of cores which should be used.  By default, all cores</span>
<span class="sd">        will be used, or as many are needed for the given number of</span>
<span class="sd">        chunks, which ever is smaller.</span>
<span class="sd">    im_arg : str</span>
<span class="sd">        The keyword used by ``func`` for the image to be operated on. By</span>
<span class="sd">        default this function will look for ``image``, ``input``, and</span>
<span class="sd">        ``im`` which are commonly used by *scipy.ndimage* and *skimage*.</span>
<span class="sd">    strel_arg : str</span>
<span class="sd">        The keyword used by ``func`` for the structuring element to apply.</span>
<span class="sd">        This is only needed if ``overlap`` is not specified. By default</span>
<span class="sd">        this function will look for ``strel``, ``structure``, and</span>
<span class="sd">        ``footprint`` which are commonly used by *scipy.ndimage* and</span>
<span class="sd">        *skimage*.</span>
<span class="sd">    kwargs</span>
<span class="sd">        All other arguments are passed to ``func`` as keyword arguments.</span>
<span class="sd">        Note that PoreSpy will fetch the image from this list of keywords</span>
<span class="sd">        using the value provided to ``im_arg``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : ndarray</span>
<span class="sd">        An image the same size as the input image, with the specified</span>
<span class="sd">        filter applied as though done on a single large image. There</span>
<span class="sd">        should be *no* difference.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function divides the image into the specified number of chunks,</span>
<span class="sd">    but also applies a padding to each chunk to create an overlap with</span>
<span class="sd">    neighboring chunks. This way the operation does not have any edge</span>
<span class="sd">    artifacts. The amount of padding is usually equal to the radius of the</span>
<span class="sd">    structuring element but some functions do not use one, such as the</span>
<span class="sd">    distance transform and Gaussian blur.  In these cases the user can</span>
<span class="sd">    specify ``overlap``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    skikit-image.util.apply_parallel</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import scipy.ndimage as spim</span>
<span class="sd">    &gt;&gt;&gt; import porespy as ps</span>
<span class="sd">    &gt;&gt;&gt; from skimage.morphology import ball</span>
<span class="sd">    &gt;&gt;&gt; im = ps.generators.blobs(shape=[100, 100, 100])</span>
<span class="sd">    &gt;&gt;&gt; f = spim.binary_dilation</span>
<span class="sd">    &gt;&gt;&gt; im2 = ps.filters.chunked_func(func=f, overlap=7, im_arg='input',</span>
<span class="sd">    ...                               input=im, structure=ball(3), cores=1)</span>
<span class="sd">    &gt;&gt;&gt; im3 = spim.binary_dilation(input=im, structure=ball(3))</span>
<span class="sd">    &gt;&gt;&gt; np.all(im2 == im3)</span>
<span class="sd">    True</span>

<span class="sd">    """</span>

    <span class="nd">@dask</span><span class="o">.</span><span class="n">delayed</span>
    <span class="k">def</span> <span class="nf">apply_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Apply function on sub-slice of overall image</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Import the array_split methods</span>
    <span class="kn">from</span> <span class="nn">array_split</span> <span class="kn">import</span> <span class="n">shape_split</span><span class="p">,</span> <span class="n">ARRAY_BOUNDS</span>

    <span class="c1"># Determine the value for im_arg</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">im_arg</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">im_arg</span> <span class="o">=</span> <span class="p">[</span><span class="n">im_arg</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">im_arg</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
            <span class="n">im_arg</span> <span class="o">=</span> <span class="n">item</span>
            <span class="k">break</span>
    <span class="c1"># Fetch image from the kwargs dict</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">im_arg</span><span class="p">]</span>
    <span class="c1"># Determine the number of divisions to create</span>
    <span class="n">divs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">im</span><span class="o">.</span><span class="n">ndim</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">divs</span><span class="p">)</span>
    <span class="c1"># If overlap given then use it, otherwise search for strel in kwargs</span>
    <span class="k">if</span> <span class="n">overlap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">halo</span> <span class="o">=</span> <span class="n">overlap</span> <span class="o">*</span> <span class="p">(</span><span class="n">divs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">strel_arg</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">strel_arg</span> <span class="o">=</span> <span class="p">[</span><span class="n">strel_arg</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">strel_arg</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">strel</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="n">halo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">strel</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">divs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">shape_split</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">divs</span><span class="p">,</span> <span class="n">halo</span><span class="o">=</span><span class="n">halo</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                                  <span class="n">tile_bounds_policy</span><span class="o">=</span><span class="n">ARRAY_BOUNDS</span><span class="p">))</span>
    <span class="c1"># Apply func to each subsection of the image</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">:</span>
        <span class="c1"># Extract subsection from image and input into kwargs</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="n">im_arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">apply_func</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
    <span class="c1"># Have dask actually compute the function on each subsection in parallel</span>
    <span class="c1"># with ProgressBar():</span>
        <span class="c1"># ims = dask.compute(res, num_workers=cores)[0]</span>
    <span class="n">ims</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="n">cores</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Finally, put the pieces back together into a single master image, im2</span>
    <span class="n">im2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
        <span class="c1"># Prepare new slice objects into main and sub-sliced image</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Slices into main image</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Slices into chunked image</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">bx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">halo</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                <span class="n">bx</span> <span class="o">=</span> <span class="n">halo</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span> <span class="o">==</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]:</span>
                <span class="n">ay</span> <span class="o">=</span> <span class="n">by</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ay</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">halo</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                <span class="n">by</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="n">halo</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">ay</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">bx</span><span class="p">,</span> <span class="n">by</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="c1"># Convert lists of slices to tuples</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="c1"># Insert image chunk into main image</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">im2</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">ims</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">b</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">'The applied filter seems to have returned a '</span>
                             <span class="o">+</span> <span class="s1">'larger image that it was sent.'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">im2</span></div>


<div class="viewcode-block" id="snow_partitioning_parallel"><a class="viewcode-back" href="../../../modules/generated/porespy.filters.snow_partitioning_parallel.html#porespy.filters.snow_partitioning_parallel">[docs]</a><span class="k">def</span> <span class="nf">snow_partitioning_parallel</span><span class="p">(</span><span class="n">im</span><span class="p">,</span>
                               <span class="n">r_max</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                               <span class="n">sigma</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
                               <span class="n">mode</span><span class="o">=</span><span class="s1">'parallel'</span><span class="p">,</span>
                               <span class="n">divs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                               <span class="n">overlap</span><span class="o">=</span><span class="s1">'dt'</span><span class="p">,</span>
                               <span class="n">zoom_factor</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                               <span class="n">num_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">return_all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Performs SNOW algorithm in parallel and serial mode to reduce time</span>
<span class="sd">    and memory usage repectively by geomertirc domain decomposition of</span>
<span class="sd">    large size image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        A binary image of porous media with 'True' values indicating</span>
<span class="sd">        phase of interest.</span>
<span class="sd">    overlap : float or int or str</span>
<span class="sd">        Overlapping thickness between two subdomains that is used to</span>
<span class="sd">        merge watershed segmented regions at intersection of two or more</span>
<span class="sd">        subdomains. Options are:</span>

<span class="sd">          - 'dt': the overlap will be calculated based on maximum distance</span>
<span class="sd">            transform in the whole image.</span>
<span class="sd">          - 'ws': the overlap will be calculated by finding the maximum</span>
<span class="sd">            dimension of the bounding box of largest segmented region. The</span>
<span class="sd">            image is scale down by 'zoom_factor' provided by user.</span>
<span class="sd">          - float: this value will be considered as overlapping thickness.</span>
<span class="sd">    divs : list or int</span>
<span class="sd">        Number of domains each axis will be divided. Options are:</span>
<span class="sd">          - scalar: it will be assigned to all axis.</span>
<span class="sd">          - list: each respective axis will be divided by its corresponding</span>
<span class="sd">            number in the list. For example [2, 3, 4] will divide z, y and</span>
<span class="sd">            x axis to 2, 3, and 4 respectively.</span>
<span class="sd">    mode : str</span>
<span class="sd">        Options are:</span>
<span class="sd">          - 'parallel': all subdomains processed using ``num_workers`` cores.</span>
<span class="sd">          - 'serial': all subdomains will be processed using 1 core.</span>
<span class="sd">    num_workers : int or None</span>
<span class="sd">        Number of cores that will be used to parallel process all domains.</span>
<span class="sd">        If None then all cores will be used but user can specify any</span>
<span class="sd">        integer values to control the memory usage.</span>
<span class="sd">    crop : bool</span>
<span class="sd">        If True the image shape is cropped to fit specified division.</span>
<span class="sd">    zoom_factor : float or int</span>
<span class="sd">        The amount of zoom appiled to image to find overlap thickness</span>
<span class="sd">        using 'ws' overlap mode.</span>
<span class="sd">    return_all : boolean</span>
<span class="sd">        If set to ``True`` a named tuple is returned containing the</span>
<span class="sd">        original image, the distance transform, and the final pore</span>
<span class="sd">        regions. The default is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    regions : ndarray</span>
<span class="sd">        Partitioned image of segmentated regions with unique labels. Each</span>
<span class="sd">        region correspond to pore body while intersection with other</span>
<span class="sd">        region correspond throat area.</span>

<span class="sd">    """</span>
    <span class="c1"># Adjust image shape according to specified dimension</span>
    <span class="n">tup</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">"results"</span><span class="p">,</span> <span class="n">field_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"im"</span><span class="p">,</span> <span class="s2">"dt"</span><span class="p">,</span> <span class="s2">"regions"</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">divs</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">divs</span> <span class="o">=</span> <span class="p">[</span><span class="n">divs</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">divs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">//</span> <span class="n">divs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">shape</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">crop</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
                <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="p">[:</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
                <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">'Image was cropped to shape </span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"Image shape incompatible with `divs`."</span><span class="p">)</span>

    <span class="c1"># Get overlap thickness from distance transform</span>
    <span class="n">chunk_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">divs</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">'Beginning parallel SNOW algorithm...'</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">'Calculating overlap thickness'</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">overlap</span> <span class="o">==</span> <span class="s1">'dt'</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">edt</span><span class="p">((</span><span class="n">im</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">parallel</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">overlap</span> <span class="o">==</span> <span class="s1">'ws'</span><span class="p">:</span>
        <span class="n">rev</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">interpolation</span><span class="o">.</span><span class="n">zoom</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">zoom</span><span class="o">=</span><span class="n">zoom_factor</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">rev</span> <span class="o">=</span> <span class="n">rev</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">edt</span><span class="p">(</span><span class="n">rev</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">rev_snow</span> <span class="o">=</span> <span class="n">snow_partitioning</span><span class="p">(</span><span class="n">rev</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">r_max</span><span class="o">=</span><span class="n">r_max</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">labels</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">rev_snow</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">counts</span> <span class="o">==</span> <span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">find_objects</span><span class="p">(</span><span class="n">rev_snow</span><span class="p">)</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rev_snow</span><span class="p">[</span><span class="n">slices</span><span class="p">[</span><span class="n">node</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">zoom_factor</span> <span class="o">*</span> <span class="mf">2.0</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">edt</span><span class="p">((</span><span class="n">im</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">parallel</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">edt</span><span class="p">((</span><span class="n">im</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">parallel</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">'Overlap thickness: </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">overlap</span><span class="p">)</span><span class="si">}</span><span class="s1"> voxels'</span><span class="p">)</span>

    <span class="c1"># Get overlap and trim depth of all image dimension</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">trim_depth</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="n">depth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">overlap</span><span class="p">)</span>
        <span class="n">trim_depth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">overlap</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">tup</span><span class="o">.</span><span class="n">im</span> <span class="o">=</span> <span class="n">im</span>
    <span class="n">tup</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span>

    <span class="c1"># Applying SNOW to image chunks</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">chunk_shape</span><span class="p">)</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">overlap</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">'none'</span><span class="p">)</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">chunked_snow</span><span class="p">,</span> <span class="n">r_max</span><span class="o">=</span><span class="n">r_max</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">overlap</span><span class="o">.</span><span class="n">trim_internal</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">trim_depth</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">'none'</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">'serial'</span><span class="p">:</span>
        <span class="n">num_workers</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">'parallel'</span><span class="p">:</span>
        <span class="n">num_workers</span> <span class="o">=</span> <span class="n">num_workers</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">'`mode` can either be `parallel` or `serial`'</span><span class="p">)</span>
    <span class="c1"># TODO: use dask ProgressBar once compatible w/ logging.</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">'Applying snow to image chunks'</span><span class="p">)</span>
    <span class="n">regions</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">num_workers</span><span class="o">=</span><span class="n">num_workers</span><span class="p">)</span>

    <span class="c1"># Relabelling watershed chunks</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">'Relabelling watershed chunks'</span><span class="p">)</span>
    <span class="n">regions</span> <span class="o">=</span> <span class="n">relabel_chunks</span><span class="p">(</span><span class="n">im</span><span class="o">=</span><span class="n">regions</span><span class="p">,</span> <span class="n">chunk_shape</span><span class="o">=</span><span class="n">chunk_shape</span><span class="p">)</span>

    <span class="c1"># Stitching watershed chunks</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">'Stitching watershed chunks'</span><span class="p">)</span>
    <span class="n">regions</span> <span class="o">=</span> <span class="n">_watershed_stitching</span><span class="p">(</span><span class="n">im</span><span class="o">=</span><span class="n">regions</span><span class="p">,</span> <span class="n">chunk_shape</span><span class="o">=</span><span class="n">chunk_shape</span><span class="p">)</span>
    <span class="n">tup</span><span class="o">.</span><span class="n">regions</span> <span class="o">=</span> <span class="n">regions</span>

    <span class="k">if</span> <span class="n">return_all</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tup</span>
    <span class="k">return</span> <span class="n">regions</span></div>


<span class="k">def</span> <span class="nf">chunked_snow</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">r_max</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.4</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Partitions the void space into pore regions using a marker-based</span>
<span class="sd">    watershed algorithm, with specially filtered peaks as markers.</span>

<span class="sd">    The SNOW network extraction algorithm (Sub-Network of an</span>
<span class="sd">    Over-segmented Watershed) was designed to handle to perculiarities of</span>
<span class="sd">    high porosity materials, but it applies well to other materials as</span>
<span class="sd">    well.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : array_like</span>
<span class="sd">        Distance transform of phase of interest in a binary image</span>
<span class="sd">    r_max : int</span>
<span class="sd">        The radius of the spherical structuring element to use in the</span>
<span class="sd">        maximum filter stage that is used to find peaks.  The default is 5</span>
<span class="sd">    sigma : float</span>
<span class="sd">        The standard deviation of the Gaussian filter used in step 1. The</span>
<span class="sd">        default is 0.4.  If 0 is given then the filter is not applied,</span>
<span class="sd">        which is useful if a distance transform is supplied as the ``im``</span>
<span class="sd">        argument that has already been processed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        An image the same shape as ``im`` with the void space partitioned</span>
<span class="sd">        into pores using a marker based watershed with the peaks found by</span>
<span class="sd">        the SNOW algorithm [1].</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Gostick, J. "A versatile and efficient network extraction algorithm</span>
<span class="sd">    using marker-based watershed segmenation".  Physical Review E. (2017)</span>

<span class="sd">    """</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">r_max</span><span class="o">=</span><span class="n">r_max</span><span class="p">)</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">trim_saddle_points</span><span class="p">(</span><span class="n">peaks</span><span class="o">=</span><span class="n">peaks</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">max_iters</span><span class="o">=</span><span class="mi">99</span><span class="p">)</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">trim_nearby_peaks</span><span class="p">(</span><span class="n">peaks</span><span class="o">=</span><span class="n">peaks</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">peaks</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">spim</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
    <span class="n">regions</span> <span class="o">=</span> <span class="n">watershed</span><span class="p">(</span><span class="n">image</span><span class="o">=-</span><span class="n">dt</span><span class="p">,</span> <span class="n">markers</span><span class="o">=</span><span class="n">peaks</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">im</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">regions</span> <span class="o">*</span> <span class="p">(</span><span class="n">im</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">constant_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Pad the image with a constant values and width.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        The image that requires padding</span>
<span class="sd">    pad_width : int</span>
<span class="sd">        The number of values that will be padded from the edges. Default</span>
<span class="sd">        values is 1.</span>
<span class="sd">    contant_value : int</span>
<span class="sd">        Pads with the specified constant value</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output: ndarray</span>
<span class="sd">        Padded image with same dimnesions as provided image</span>

<span class="sd">    """</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">pad_shape</span> <span class="o">=</span> <span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pad_width</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">pad_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">constant_value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">+</span> <span class="n">constant_value</span>
    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">pad_width</span><span class="p">:</span> <span class="o">-</span><span class="n">pad_width</span><span class="p">,</span>
             <span class="n">pad_width</span><span class="p">:</span> <span class="o">-</span><span class="n">pad_width</span><span class="p">,</span>
             <span class="n">pad_width</span><span class="p">:</span> <span class="o">-</span><span class="n">pad_width</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span>
    <span class="k">elif</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">pad_width</span><span class="p">:</span> <span class="o">-</span><span class="n">pad_width</span><span class="p">,</span>
             <span class="n">pad_width</span><span class="p">:</span> <span class="o">-</span><span class="n">pad_width</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">pad_width</span><span class="p">:</span> <span class="o">-</span><span class="n">pad_width</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span>

    <span class="k">return</span> <span class="n">temp</span>


<span class="k">def</span> <span class="nf">relabel_chunks</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">chunk_shape</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Assign new labels to each chunk or sub-domain of actual image. This</span>
<span class="sd">    prevents from two or more regions to have same label.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im: ndarray</span>
<span class="sd">        Actual image that contains repeating labels in chunks/sub-domains.</span>

<span class="sd">    chunk_shape: tuple</span>
<span class="sd">        The shape of chunk that will be relabeled in actual image. Note</span>
<span class="sd">        the chunk shape should be a multiple of actual image shape</span>
<span class="sd">        otherwise some labels will not be relabeled.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : ndarray</span>
<span class="sd">        Relabeled image with unique label assigned to each region.</span>

<span class="sd">    """</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">pad</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">im_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="n">max_num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chunk_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">im_shape</span> <span class="o">/</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="n">chunk</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">z</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="p">(</span><span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                               <span class="n">y</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                               <span class="n">x</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                    <span class="n">chunk</span> <span class="o">+=</span> <span class="n">max_num</span>
                    <span class="n">chunk</span><span class="p">[</span><span class="n">chunk</span> <span class="o">==</span> <span class="n">max_num</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">max_num</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                    <span class="n">im</span><span class="p">[</span><span class="n">z</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="p">(</span><span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                       <span class="n">y</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                       <span class="n">x</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">chunk</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">chunk</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">y</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                           <span class="n">x</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">chunk</span> <span class="o">+=</span> <span class="n">max_num</span>
                <span class="n">chunk</span><span class="p">[</span><span class="n">chunk</span> <span class="o">==</span> <span class="n">max_num</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">max_num</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                <span class="n">im</span><span class="p">[</span><span class="n">y</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                   <span class="n">x</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">chunk</span>

    <span class="k">return</span> <span class="n">im</span>


<span class="k">def</span> <span class="nf">_trim_internal_slice</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">chunk_shape</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Delete extra slices from image that were used to stitch two or more</span>
<span class="sd">    chunks together.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    im :  ND-array</span>
<span class="sd">        image that contains extra slices in x, y, z direction.</span>

<span class="sd">    chunk_shape : tuple</span>
<span class="sd">        The shape of the chunk from which image is subdivided.</span>

<span class="sd">    Return:</span>
<span class="sd">    -------</span>
<span class="sd">    output : ndarray</span>
<span class="sd">        Image without extra internal slices. The shape of the image will</span>
<span class="sd">        be same as input image provided for waterhsed segmentation.</span>

<span class="sd">    """</span>
    <span class="n">im_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chunk_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chunk_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">im_shape</span> <span class="o">/</span> <span class="n">c1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">out_shape</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="n">c2</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">out_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="n">chunk</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">z</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="p">(</span><span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                               <span class="n">y</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                               <span class="n">x</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

                    <span class="n">out</span><span class="p">[</span><span class="n">z</span> <span class="o">*</span> <span class="n">c2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="p">(</span><span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">y</span> <span class="o">*</span> <span class="n">c2</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">x</span> <span class="o">*</span> <span class="n">c2</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c2</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">chunk</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">y</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                           <span class="n">x</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c1</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

                <span class="n">out</span><span class="p">[</span><span class="n">y</span> <span class="o">*</span> <span class="n">c2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">x</span> <span class="o">*</span> <span class="n">c2</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">_watershed_stitching</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">chunk_shape</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Stitch individual sub-domains of watershed segmentation into one big</span>
<span class="sd">    segmentation with all boundary labels of each sub-domain relabeled to</span>
<span class="sd">    merge boundary regions.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        A worked image with watershed segmentation performed on all</span>
<span class="sd">        sub-domains individually.</span>

<span class="sd">    chunk_shape: tuple</span>
<span class="sd">        The shape of the sub-domain in which segmentation is performed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : ndarray</span>
<span class="sd">        Stitched watershed segmentation with all sub-domains merged to</span>
<span class="sd">        form a single watershed segmentation.</span>

<span class="sd">    """</span>
    <span class="n">c_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chunk_shape</span><span class="p">)</span>
    <span class="n">cuts_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="n">c_shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cuts_num</span><span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">chunk_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">sl1</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">sl</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                <span class="n">sl1_mask</span> <span class="o">=</span> <span class="n">sl1</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="n">sl2</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">sl</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">sl1_mask</span>
                <span class="n">sl1_labels</span> <span class="o">=</span> <span class="n">sl1</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">sl1</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">sl2_labels</span> <span class="o">=</span> <span class="n">sl2</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">sl2</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">sl1_labels</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">sl2_labels</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">'The selected overlapping thickness is not '</span>
                                    <span class="s1">'suitable for input image. Change '</span>
                                    <span class="s1">'overlapping criteria '</span>
                                    <span class="s1">'or manually input value.'</span><span class="p">)</span>
                <span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl1_labels</span><span class="p">)</span>
                <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl2_labels</span><span class="p">)</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">_replace_labels</span><span class="p">(</span><span class="n">array</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">_trim_internal_slice</span><span class="p">(</span><span class="n">im</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">chunk_shape</span><span class="o">=</span><span class="n">chunk_shape</span><span class="p">)</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">_resequence_labels</span><span class="p">(</span><span class="n">array</span><span class="o">=</span><span class="n">im</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">im</span>


<span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_copy</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    The function copy the input array and make output array that is</span>
<span class="sd">    allocated in different memory space. This a numba version of copy</span>
<span class="sd">    function of numpy. Because each element is copied using parallel</span>
<span class="sd">    approach this implementation is faster than numpy version of copy.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array: ndarray</span>
<span class="sd">        Array that needs to be copied.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output: ndarray</span>
<span class="sd">        Copied array.</span>

<span class="sd">    """</span>

    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">output</span>


<span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_replace</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">ind_sort</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    This function replace keys elements in input array with new value</span>
<span class="sd">    elements. This function is used as internal function of</span>
<span class="sd">    replace_relabels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : ndarray</span>
<span class="sd">        Array which requires replacing labels.</span>
<span class="sd">    keys :  ndarray</span>
<span class="sd">        1d array containing unique labels that need to be replaced.</span>
<span class="sd">    values : ndarray</span>
<span class="sd">        1d array containing unique values that will be assigned to labels.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array : ndarray</span>
<span class="sd">        Array with replaced labels.</span>

<span class="sd">    """</span>
    <span class="c1"># ind_sort = np.argsort(keys)</span>
    <span class="n">keys_sorted</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">ind_sort</span><span class="p">]</span>
    <span class="n">values_sorted</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">ind_sort</span><span class="p">]</span>
    <span class="n">s_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">s_keys</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">keys_sorted</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">values_sorted</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_replace_labels</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Replace labels in array provided as keys to values.</span>

<span class="sd">    Parameter:</span>
<span class="sd">    ----------</span>
<span class="sd">    array : ND-array</span>
<span class="sd">        Array which requires replacing labels</span>
<span class="sd">    keys :  1D-array</span>
<span class="sd">        The unique labels that need to be replaced</span>
<span class="sd">    values : 1D-array</span>
<span class="sd">        The unique values that will be assigned to labels</span>

<span class="sd">    return:</span>
<span class="sd">    -------</span>
<span class="sd">    array : ND-array</span>
<span class="sd">        Array with replaced labels.</span>
<span class="sd">    """</span>
    <span class="n">a_shape</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ind_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
    <span class="n">_replace</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">ind_sort</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a_shape</span><span class="p">)</span>


<span class="nd">@njit</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">_sequence</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Internal function of resequnce_labels method. This function resquence</span>
<span class="sd">    array elements in an ascending order using numba technique which is</span>
<span class="sd">    many folds faster than make contigious funcition.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array: ndarray</span>
<span class="sd">        1d array that needs resquencing.</span>
<span class="sd">    count: ndarray</span>
<span class="sd">        1d array of zeros having same size as array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array: 1d-array</span>
<span class="sd">        The input array with elements resequenced in ascending order</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The output of this function is not same as make_contigous or</span>
<span class="sd">    relabel_sequential function of scikit-image. This function resequence</span>
<span class="sd">    and randomize the regions while other methods only do resequencing and</span>
<span class="sd">    output sorted array.</span>

<span class="sd">    """</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">data</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">count</span><span class="p">[</span><span class="n">data</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">count</span><span class="p">[</span><span class="n">data</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
                <span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">[</span><span class="n">data</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_amax</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Find largest element in an array using fast parallel numba technique.</span>

<span class="sd">    Parameter:</span>
<span class="sd">    ----------</span>
<span class="sd">    array: ndarray</span>
<span class="sd">        Array in which largest elements needs to be calcuted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scalar: float or int</span>
<span class="sd">        The largest element value in the input array.</span>

<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_resequence_labels</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Resequence the lablels to make them contigious.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array: ndarray</span>
<span class="sd">        Array that requires resequencing.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array : ndarray</span>
<span class="sd">        Resequenced array with same shape as input array.</span>

<span class="sd">    """</span>
    <span class="n">a_shape</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">max_num</span> <span class="o">=</span> <span class="n">_amax</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_num</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="n">_sequence</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a_shape</span><span class="p">)</span>
</pre></div>
      </article>
      <footer>
        
        <div class="related-pages">
          
          
        </div>

        <div class="related-information">
              Copyright &#169; 2021 PoreSpy Team
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </main>
</div>
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/scripts/main.js?digest=e931d09b2a40c1bb82b542effe772014573baf67"></script></body>
</html>